{
  "version" : "0.0.23-SNAPSHOT",
  "agents" : {
    "ai-chat-completions" : {
      "name" : "Compute chat completions",
      "description" : "Sends the messages to the AI Service to compute chat completions. The result is stored in the specified field.",
      "properties" : {
        "ai-service" : {
          "description" : "In case of multiple AI services configured, specify the id of the AI service to use.",
          "required" : false,
          "type" : "string"
        },
        "completion-field" : {
          "description" : "Field to use to store the completion results in the output topic. Use \"value\" to write the result without a structured schema. Use \"value.<field>\" to write the result in a specific field.",
          "required" : false,
          "type" : "string"
        },
        "composable" : {
          "description" : "Whether this step can be composed with other steps.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "frequency-penalty" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "number"
        },
        "log-field" : {
          "description" : "Field to use to store the log of the completion results in the output topic. Use \"value\" to write the result without a structured schema. Use \"value.<field>\" to write the result in a specific field.\nThe log contains useful information for debugging the completion prompts.",
          "required" : false,
          "type" : "string"
        },
        "logit-bias" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "object"
        },
        "max-tokens" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "integer"
        },
        "messages" : {
          "description" : "Messages to use for chat completions. You can use the Mustache syntax.",
          "required" : true,
          "type" : "array",
          "items" : {
            "description" : "Messages to use for chat completions. You can use the Mustache syntax.",
            "required" : true,
            "type" : "object",
            "properties" : {
              "role" : {
                "description" : "Role of the message. The role is used to identify the speaker in the chat.",
                "required" : true,
                "type" : "string"
              },
              "content" : {
                "description" : "Content of the message. You can use the Mustache syntax.",
                "required" : true,
                "type" : "string"
              }
            }
          }
        },
        "min-chunks-per-message" : {
          "description" : "Minimum number of chunks to send to the stream-to-topic topic. The chunks are sent as soon as they are available.\nThe chunks are sent in the order they are received from the AI Service.\nTo improve the TTFB (Time-To-First-Byte), the chunk size starts from 1 and doubles until it reaches the max-chunks-per-message value.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "20"
        },
        "model" : {
          "description" : "The model to use for chat completions. The model must be available in the AI Service.",
          "required" : true,
          "type" : "string"
        },
        "presence-penalty" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "number"
        },
        "stop" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "array",
          "items" : {
            "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
            "required" : false,
            "type" : "string"
          }
        },
        "stream" : {
          "description" : "Enable streaming of the results. Use in conjunction with the stream-to-topic parameter.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "stream-response-completion-field" : {
          "description" : "Field to use to store the completion results in the stream-to-topic topic. Use \"value\" to write the result without a structured schema. Use \"value.<field>\" to write the result in a specific field.",
          "required" : false,
          "type" : "string"
        },
        "stream-to-topic" : {
          "description" : "Enable streaming of the results. If enabled, the results are streamed to the specified topic in small chunks. The entire messages will be sent to the output topic instead.",
          "required" : false,
          "type" : "string"
        },
        "temperature" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "number"
        },
        "top-p" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "number"
        },
        "user" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "string"
        },
        "when" : {
          "description" : "Execute the step only when the condition is met.\nYou can use the expression language to reference the message.\nExample: when: \"value.first == 'f1' && value.last.toUpperCase() == 'L1'\"",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "ai-text-completions" : {
      "name" : "Compute text completions",
      "description" : "Sends the text to the AI Service to compute text completions. The result is stored in the specified field.",
      "properties" : {
        "ai-service" : {
          "description" : "In case of multiple AI services configured, specify the id of the AI service to use.",
          "required" : false,
          "type" : "string"
        },
        "completion-field" : {
          "description" : "Field to use to store the completion results in the output topic. Use \"value\" to write the result without a structured schema. Use \"value.<field>\" to write the result in a specific field.",
          "required" : false,
          "type" : "string"
        },
        "composable" : {
          "description" : "Whether this step can be composed with other steps.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "frequency-penalty" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "number"
        },
        "log-field" : {
          "description" : "Field to use to store the log of the completion results in the output topic. Use \"value\" to write the result without a structured schema. Use \"value.<field>\" to write the result in a specific field.\nThe log contains useful information for debugging the completion prompts.",
          "required" : false,
          "type" : "string"
        },
        "logit-bias" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "object"
        },
        "max-tokens" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "integer"
        },
        "min-chunks-per-message" : {
          "description" : "Minimum number of chunks to send to the stream-to-topic topic. The chunks are sent as soon as they are available.\nThe chunks are sent in the order they are received from the AI Service.\nTo improve the TTFB (Time-To-First-Byte), the chunk size starts from 1 and doubles until it reaches the max-chunks-per-message value.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "20"
        },
        "model" : {
          "description" : "The model to use for text completions. The model must be available in the AI Service.",
          "required" : true,
          "type" : "string"
        },
        "presence-penalty" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "number"
        },
        "prompt" : {
          "description" : "Prompt to use for text completions. You can use the Mustache syntax.",
          "required" : true,
          "type" : "array",
          "items" : {
            "description" : "Prompt to use for text completions. You can use the Mustache syntax.",
            "required" : true,
            "type" : "string"
          }
        },
        "stop" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "array",
          "items" : {
            "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
            "required" : false,
            "type" : "string"
          }
        },
        "stream" : {
          "description" : "Enable streaming of the results. Use in conjunction with the stream-to-topic parameter.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "stream-response-completion-field" : {
          "description" : "Field to use to store the completion results in the stream-to-topic topic. Use \"value\" to write the result without a structured schema. Use \"value.<field>\" to write the result in a specific field.",
          "required" : false,
          "type" : "string"
        },
        "stream-to-topic" : {
          "description" : "Enable streaming of the results. If enabled, the results are streamed to the specified topic in small chunks. The entire messages will be sent to the output topic instead.",
          "required" : false,
          "type" : "string"
        },
        "temperature" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "number"
        },
        "top-p" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "number"
        },
        "user" : {
          "description" : "Parameter for the completion request. The parameters are passed to the AI Service as is.",
          "required" : false,
          "type" : "string"
        },
        "when" : {
          "description" : "Execute the step only when the condition is met.\nYou can use the expression language to reference the message.\nExample: when: \"value.first == 'f1' && value.last.toUpperCase() == 'L1'\"",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "cast" : {
      "name" : "Cast record to another schema",
      "description" : "Transforms the data to a target compatible schema.\nSome step operations like cast or compute involve conversions from a type to another. When this happens the rules are:\n    - timestamp, date and time related object conversions assume UTC time zone if it is not explicit.\n    - date and time related object conversions to/from STRING use the RFC3339 format.\n    - timestamp related object conversions to/from LONG and DOUBLE are done using the number of milliseconds since EPOCH (1970-01-01T00:00:00Z).\n    - date related object conversions to/from INTEGER, LONG, FLOAT and DOUBLE are done using the number of days since EPOCH (1970-01-01).\n    - time related object conversions to/from INTEGER, LONG and DOUBLE are done using the number of milliseconds since midnight (00:00:00).",
      "properties" : {
        "composable" : {
          "description" : "Whether this step can be composed with other steps.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "part" : {
          "description" : "When used with KeyValue data, defines if the transformation is done on the key or on the value. If empty, the transformation applies to both the key and the value.",
          "required" : false,
          "type" : "string"
        },
        "schema-type" : {
          "description" : "The target schema type.",
          "required" : true,
          "type" : "string"
        },
        "when" : {
          "description" : "Execute the step only when the condition is met.\nYou can use the expression language to reference the message.\nExample: when: \"value.first == 'f1' && value.last.toUpperCase() == 'L1'\"",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "compute" : {
      "name" : "Compute values from the record",
      "description" : "Computes new properties, values or field values based on an expression evaluated at runtime. If the field already exists, it will be overwritten.",
      "properties" : {
        "composable" : {
          "description" : "Whether this step can be composed with other steps.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "fields" : {
          "description" : "An array of objects describing how to calculate the field values",
          "required" : true,
          "type" : "array",
          "items" : {
            "description" : "An array of objects describing how to calculate the field values",
            "required" : true,
            "type" : "object",
            "properties" : {
              "expression" : {
                "description" : "It is evaluated at runtime and the result of the evaluation is assigned to the field.\nRefer to the language expression documentation for more information on the expression syntax.",
                "required" : true,
                "type" : "string"
              },
              "name" : {
                "description" : "The name of the field to be computed. Prefix with key. or value. to compute the fields in the key or value parts of the message.\nIn addition, you can compute values on the following message headers [destinationTopic, messageKey, properties.].\nPlease note that properties is a map of key/value pairs that are referenced by the dot notation, for example properties.key0.",
                "required" : true,
                "type" : "string"
              },
              "optional" : {
                "description" : "If true, it marks the field as optional in the schema of the transformed message. This is useful when null is a possible value of the compute expression.",
                "required" : false,
                "type" : "boolean",
                "defaultValue" : "false"
              },
              "type" : {
                "description" : "The type of the computed field. This\n will translate to the schema type of the new field in the transformed message.\n The following types are currently supported :STRING, INT8, INT16, INT32, INT64, FLOAT, DOUBLE, BOOLEAN, DATE, TIME, TIMESTAMP, LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, INSTANT.\n  The type field is not required for the message headers [destinationTopic, messageKey, properties.] and STRING will be used.\n  For the value and key, if it is not provided, then the type will be inferred from the result of the expression evaluation.",
                "required" : true,
                "type" : "string"
              }
            }
          }
        },
        "when" : {
          "description" : "Execute the step only when the condition is met.\nYou can use the expression language to reference the message.\nExample: when: \"value.first == 'f1' && value.last.toUpperCase() == 'L1'\"",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "compute-ai-embeddings" : {
      "name" : "Compute embeddings of the record",
      "description" : "Compute embeddings of the record. The embeddings are stored in the record under a specific field.",
      "properties" : {
        "ai-service" : {
          "description" : "In case of multiple AI services configured, specify the id of the AI service to use.",
          "required" : false,
          "type" : "string"
        },
        "arguments" : {
          "description" : "Additional arguments to pass to the AI Service. (HuggingFace only)",
          "required" : false,
          "type" : "object"
        },
        "batch-size" : {
          "description" : "Batch size for submitting the embeddings requests.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "10"
        },
        "composable" : {
          "description" : "Whether this step can be composed with other steps.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "concurrency" : {
          "description" : "Max number of concurrent requests to the AI Service.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "4"
        },
        "embeddings-field" : {
          "description" : "Field where to store the embeddings.",
          "required" : true,
          "type" : "string"
        },
        "flush-interval" : {
          "description" : "Flushing is disabled by default in order to avoid latency spikes.\nYou should enable this feature in the case of background processing.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "0"
        },
        "model" : {
          "description" : "Model to use for the embeddings. The model must be available in the configured AI Service.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "text-embedding-ada-002"
        },
        "modelUrl" : {
          "description" : "URL of the model to use. (HuggingFace only). The default is computed from the model: \"djl://ai.djl.huggingface.pytorch{model}\"",
          "required" : false,
          "type" : "string"
        },
        "options" : {
          "description" : "Additional options to pass to the AI Service. (HuggingFace only)",
          "required" : false,
          "type" : "object"
        },
        "text" : {
          "description" : "Text to create embeddings from. You can use Mustache syntax to compose multiple fields into a single text. Example:\ntext: \"{{{ value.field1 }}} {{{ value.field2 }}}\"",
          "required" : true,
          "type" : "string"
        },
        "when" : {
          "description" : "Execute the step only when the condition is met.\nYou can use the expression language to reference the message.\nExample: when: \"value.first == 'f1' && value.last.toUpperCase() == 'L1'\"",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "document-to-json" : {
      "name" : "Document to JSON",
      "description" : "Convert raw text document to JSON. The result will be a JSON object with the text content in the specified field.",
      "properties" : {
        "copy-properties" : {
          "description" : "Whether to copy the message properties/headers in the output message.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "text-field" : {
          "description" : "Field name to write the text content to.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "text"
        }
      }
    },
    "drop" : {
      "name" : "Drop the record",
      "description" : "Drops the record from further processing. Use in conjunction with when to selectively drop records.",
      "properties" : {
        "composable" : {
          "description" : "Whether this step can be composed with other steps.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "when" : {
          "description" : "Execute the step only when the condition is met.\nYou can use the expression language to reference the message.\nExample: when: \"value.first == 'f1' && value.last.toUpperCase() == 'L1'\"",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "drop-fields" : {
      "name" : "Drop fields",
      "description" : "Drops the record fields.",
      "properties" : {
        "composable" : {
          "description" : "Whether this step can be composed with other steps.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "fields" : {
          "description" : "Fields to drop from the input record.",
          "required" : true,
          "type" : "array",
          "items" : {
            "description" : "Fields to drop from the input record.",
            "required" : true,
            "type" : "string"
          }
        },
        "part" : {
          "description" : "Part to drop. (value or key)",
          "required" : false,
          "type" : "string"
        },
        "when" : {
          "description" : "Execute the step only when the condition is met.\nYou can use the expression language to reference the message.\nExample: when: \"value.first == 'f1' && value.last.toUpperCase() == 'L1'\"",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "flatten" : {
      "name" : "Flatten record fields",
      "description" : "Converts structured nested data into a new single-hierarchy-level structured data. The names of the new fields are built by concatenating the intermediate level field names.",
      "properties" : {
        "composable" : {
          "description" : "Whether this step can be composed with other steps.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "delimiter" : {
          "description" : "The delimiter to use when concatenating the field names.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "_"
        },
        "part" : {
          "description" : "When used with KeyValue data, defines if the transformation is done on the key or on the value. If empty, the transformation applies to both the key and the value.",
          "required" : false,
          "type" : "string"
        },
        "when" : {
          "description" : "Execute the step only when the condition is met.\nYou can use the expression language to reference the message.\nExample: when: \"value.first == 'f1' && value.last.toUpperCase() == 'L1'\"",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "identity" : {
      "name" : "Identity function",
      "description" : "Simple agent to move data from the input to the output. Could be used for testing or sample applications.",
      "properties" : { }
    },
    "language-detector" : {
      "name" : "Language detector",
      "description" : "Detect the language of a message’s data and limit further processing based on language codes.",
      "properties" : {
        "allowedLanguages" : {
          "description" : "Define a list of allowed language codes. If the message language is not in this list, the message is dropped.",
          "required" : false,
          "type" : "array",
          "items" : {
            "description" : "Define a list of allowed language codes. If the message language is not in this list, the message is dropped.",
            "required" : false,
            "type" : "string"
          }
        },
        "property" : {
          "description" : "The name of the message header to write the language code to.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "language"
        }
      }
    },
    "merge-key-value" : {
      "name" : "Merge key-value format",
      "description" : "Merges the fields of KeyValue records where both the key and value are structured types of the same schema type. Only AVRO and JSON are supported.",
      "properties" : {
        "composable" : {
          "description" : "Whether this step can be composed with other steps.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "when" : {
          "description" : "Execute the step only when the condition is met.\nYou can use the expression language to reference the message.\nExample: when: \"value.first == 'f1' && value.last.toUpperCase() == 'L1'\"",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "python-function" : {
      "name" : "Python custom processor",
      "description" : "Run a your own Python processor.\nAll the configuration properties are available the class init method.",
      "properties" : {
        "className" : {
          "description" : "Python class name to instantiate. This class must be present in the application's \"python\" files.",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "python-processor" : {
      "name" : "Python custom processor",
      "description" : "Run a your own Python processor.\nAll the configuration properties are available the class init method.",
      "properties" : {
        "className" : {
          "description" : "Python class name to instantiate. This class must be present in the application's \"python\" files.",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "python-sink" : {
      "name" : "Python custom sink",
      "description" : "Run a your own Python sink.\nAll the configuration properties are available in the class init method.",
      "properties" : {
        "className" : {
          "description" : "Python class name to instantiate. This class must be present in the application's \"python\" files.",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "python-source" : {
      "name" : "Python custom source",
      "description" : "Run a your own Python source.\nAll the configuration properties are available in the class init method.",
      "properties" : {
        "className" : {
          "description" : "Python class name to instantiate. This class must be present in the application's \"python\" files.",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "query" : {
      "name" : "Query",
      "description" : "Perform a vector search or simple query against a datasource.",
      "properties" : {
        "composable" : {
          "description" : "Whether this step can be composed with other steps.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "datasource" : {
          "description" : "Reference to a datasource id configured in the application.",
          "required" : true,
          "type" : "string"
        },
        "fields" : {
          "description" : "Fields of the record to use as input parameters for the query.",
          "required" : false,
          "type" : "array",
          "items" : {
            "description" : "Fields of the record to use as input parameters for the query.",
            "required" : false,
            "type" : "string"
          }
        },
        "only-first" : {
          "description" : "If true, only the first result of the query is stored in the output field.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "false"
        },
        "output-field" : {
          "description" : "The name of the field to use to store the query result.",
          "required" : true,
          "type" : "string"
        },
        "query" : {
          "description" : "The query to use to extract the data.",
          "required" : true,
          "type" : "string"
        },
        "when" : {
          "description" : "Execute the step only when the condition is met.\nYou can use the expression language to reference the message.\nExample: when: \"value.first == 'f1' && value.last.toUpperCase() == 'L1'\"",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "query-vector-db" : {
      "name" : "Query a vector database",
      "description" : "Query a vector database using Vector Search capabilities.",
      "properties" : {
        "composable" : {
          "description" : "Whether this step can be composed with other steps.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "datasource" : {
          "description" : "Reference to a datasource id configured in the application.",
          "required" : true,
          "type" : "string"
        },
        "fields" : {
          "description" : "Fields of the record to use as input parameters for the query.",
          "required" : false,
          "type" : "array",
          "items" : {
            "description" : "Fields of the record to use as input parameters for the query.",
            "required" : false,
            "type" : "string"
          }
        },
        "only-first" : {
          "description" : "If true, only the first result of the query is stored in the output field.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "false"
        },
        "output-field" : {
          "description" : "The name of the field to use to store the query result.",
          "required" : true,
          "type" : "string"
        },
        "query" : {
          "description" : "The query to use to extract the data.",
          "required" : true,
          "type" : "string"
        },
        "when" : {
          "description" : "Execute the step only when the condition is met.\nYou can use the expression language to reference the message.\nExample: when: \"value.first == 'f1' && value.last.toUpperCase() == 'L1'\"",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "re-rank" : {
      "name" : "Re-rank",
      "description" : "Agent for re-ranking documents based on a query.",
      "properties" : {
        "algorithm" : {
          "description" : "Algorithm to use for re-ranking. 'none' or 'MMR'.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "none"
        },
        "b" : {
          "description" : "Parameter for B25 algorithm.",
          "required" : false,
          "type" : "number",
          "defaultValue" : "0.75"
        },
        "embeddings-field" : {
          "description" : "Result field for the embeddings.",
          "required" : false,
          "type" : "string"
        },
        "field" : {
          "description" : "The field that contains the documents to sort.",
          "required" : true,
          "type" : "string"
        },
        "k1" : {
          "description" : "Parameter for B25 algorithm.",
          "required" : false,
          "type" : "number",
          "defaultValue" : "1.5"
        },
        "lambda" : {
          "description" : "Parameter for MMR algorithm.",
          "required" : false,
          "type" : "number",
          "defaultValue" : "0.5"
        },
        "max" : {
          "description" : "Maximum number of documents to keep.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "100"
        },
        "output-field" : {
          "description" : "The field that will hold the results, it can be the same as \"field\" to override it.",
          "required" : true,
          "type" : "string"
        },
        "query-embeddings" : {
          "description" : "Field that contains the embeddings of the documents to sort.",
          "required" : false,
          "type" : "string"
        },
        "query-text" : {
          "description" : "Field that already contains the text that has been embedded.",
          "required" : false,
          "type" : "string"
        },
        "text-field" : {
          "description" : "Result field for the text.",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "s3-source" : {
      "name" : "S3 Source",
      "description" : "Reads data from S3 bucket",
      "properties" : {
        "access-key" : {
          "description" : "Access key for the S3 server.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "minioadmin"
        },
        "bucketName" : {
          "description" : "The name of the bucket to read from.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "langstream-source"
        },
        "endpoint" : {
          "description" : "The endpoint of the S3 server.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "http://minio-endpoint.-not-set:9090"
        },
        "file-extensions" : {
          "description" : "Comma separated list of file extensions to filter by.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "pdf,docx,html,htm,md,txt"
        },
        "idle-time" : {
          "description" : "Region for the S3 server.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "5"
        },
        "region" : {
          "description" : "Region for the S3 server.",
          "required" : false,
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Secret key for the S3 server.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "minioadmin"
        }
      }
    },
    "sink" : {
      "name" : "Kafka Connect Sink agent",
      "description" : "Run any Kafka Connect Sink.\n    All the configuration properties are passed to the Kafka Connect Sink.",
      "properties" : {
        "connector.class" : {
          "description" : "Java main class for the Kafka Sink connector.",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "source" : {
      "name" : "Kafka Connect Source agent",
      "description" : "Run any Kafka Connect Source.\n    All the configuration properties are passed to the Kafka Connect Source.",
      "properties" : {
        "connector.class" : {
          "description" : "Java main class for the Kafka Source connector.",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "text-extractor" : {
      "name" : "Text extractor",
      "description" : "Extracts text content from different document formats like PDF, JSON, XML, ODF, HTML and many others.",
      "properties" : { }
    },
    "text-normaliser" : {
      "name" : "Text normaliser",
      "description" : "Apply normalisation to the text.",
      "properties" : {
        "make-lowercase" : {
          "description" : "Whether to make the text lowercase.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "trim-spaces" : {
          "description" : "Whether to trim spaces from the text.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        }
      }
    },
    "text-splitter" : {
      "name" : "Text splitter",
      "description" : "Split message content in chunks.",
      "properties" : {
        "chunk_overlap" : {
          "description" : "RecursiveCharacterTextSplitter splitter option. Chunk overlap of the previous message.\nCheckout https://github.com/knuddelsgmbh/jtokkit for more details.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "100"
        },
        "chunk_size" : {
          "description" : "RecursiveCharacterTextSplitter splitter option. Chunk size of each message.\nCheckout https://github.com/knuddelsgmbh/jtokkit for more details.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "200"
        },
        "keep_separator" : {
          "description" : "RecursiveCharacterTextSplitter splitter option. Whether or not to keep separators.\nCheckout https://github.com/knuddelsgmbh/jtokkit for more details.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "false"
        },
        "length_function" : {
          "description" : "RecursiveCharacterTextSplitter splitter option. Options are: r50k_base, p50k_base, p50k_edit and cl100k_base.\nCheckout https://github.com/knuddelsgmbh/jtokkit for more details.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "cl100k_base"
        },
        "separators" : {
          "description" : "RecursiveCharacterTextSplitter splitter option. The separator to use for splitting.\nCheckout https://github.com/knuddelsgmbh/jtokkit for more details.",
          "required" : false,
          "type" : "array",
          "items" : {
            "description" : "RecursiveCharacterTextSplitter splitter option. The separator to use for splitting.\nCheckout https://github.com/knuddelsgmbh/jtokkit for more details.",
            "required" : false,
            "type" : "string",
            "defaultValue" : "\"\\n\\n\", \"\\n\", \" \", \"\""
          },
          "defaultValue" : "\"\\n\\n\", \"\\n\", \" \", \"\""
        },
        "splitter_type" : {
          "description" : "Splitter implementation to use. Currently supported: RecursiveCharacterTextSplitter.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "RecursiveCharacterTextSplitter"
        }
      }
    },
    "unwrap-key-value" : {
      "name" : "Unwrap key-value format",
      "description" : "If the record value is in KeyValue format, extracts the KeyValue's key or value and make it the record value.",
      "properties" : {
        "composable" : {
          "description" : "Whether this step can be composed with other steps.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "unwrapKey" : {
          "description" : "Whether to unwrap the key instead of the value.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "false"
        },
        "when" : {
          "description" : "Execute the step only when the condition is met.\nYou can use the expression language to reference the message.\nExample: when: \"value.first == 'f1' && value.last.toUpperCase() == 'L1'\"",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "vector-db-sink" : {
      "name" : "Vector database sink",
      "description" : "Store vectors in a vector database.\nConfiguration properties depends on the vector database implementation, specified by the \"datasource\" property.",
      "properties" : {
        "datasource" : {
          "description" : "The defined datasource ID to use to store the vectors.",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "webcrawler-source" : {
      "name" : "Web crawler source",
      "description" : "Crawl a website and extract the content of the pages.",
      "properties" : {
        "access-key" : {
          "description" : "Configuration for handling the agent status.\nAccess key for the S3 server.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "minioadmin"
        },
        "allowed-domains" : {
          "description" : "Domains that the crawler is allowed to access.",
          "required" : false,
          "type" : "array",
          "items" : {
            "description" : "Domains that the crawler is allowed to access.",
            "required" : false,
            "type" : "string"
          }
        },
        "bucketName" : {
          "description" : "Configuration for handling the agent status.\nThe name of the bucket.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "langstream-source"
        },
        "endpoint" : {
          "description" : "Configuration for handling the agent status.\nThe S3 endpoint.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "http://minio-endpoint.-not-set:9090"
        },
        "forbidden-paths" : {
          "description" : "Paths that the crawler is not allowed to access.",
          "required" : false,
          "type" : "array",
          "items" : {
            "description" : "Paths that the crawler is not allowed to access.",
            "required" : false,
            "type" : "string"
          }
        },
        "handle-cookies" : {
          "description" : "Whether to handle cookies.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "handle-robots-file" : {
          "description" : "Whether to scan the HTML documents to find links to other pages.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "http-timeout" : {
          "description" : "Timeout for HTTP requests. (in milliseconds)",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "10000"
        },
        "max-depth" : {
          "description" : "Maximum depth of the crawl.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "50"
        },
        "max-error-count" : {
          "description" : "Maximum number of errors allowed before stopping.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "5"
        },
        "max-unflushed-pages" : {
          "description" : "Maximum number of unflushed pages before the agent persists the crawl data.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "100"
        },
        "max-urls" : {
          "description" : "Maximum number of URLs that can be crawled.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "1000"
        },
        "min-time-between-requests" : {
          "description" : "Minimum time between two requests to the same domain. (in milliseconds)",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "500"
        },
        "region" : {
          "description" : "Configuration for handling the agent status.\nRegion for the S3 server.",
          "required" : false,
          "type" : "string"
        },
        "reindex-interval-seconds" : {
          "description" : "Time interval between reindexing of the pages.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "86400"
        },
        "scan-html-documents" : {
          "description" : "Whether to scan HTML documents for links to other sites.",
          "required" : false,
          "type" : "boolean",
          "defaultValue" : "true"
        },
        "secret-key" : {
          "description" : "Configuration for handling the agent status.\nSecret key for the S3 server.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "minioadmin"
        },
        "seed-urls" : {
          "description" : "The starting URLs for the crawl.",
          "required" : false,
          "type" : "array",
          "items" : {
            "description" : "The starting URLs for the crawl.",
            "required" : false,
            "type" : "string"
          }
        },
        "user-agent" : {
          "description" : "User agent to use for the requests.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "Mozilla/5.0 (compatible; LangStream.ai/0.1; +https://langstream.ai)"
        }
      }
    }
  },
  "resources" : {
    "datasource_astra" : {
      "type" : "datasource",
      "name" : "Astra",
      "description" : "Connect to DataStax Astra Database service.",
      "properties" : {
        "clientId" : {
          "description" : "Astra Token clientId to use.",
          "required" : true,
          "type" : "string"
        },
        "database" : {
          "description" : "Astra Database name to connect to. If secureBundle is provided, this field is ignored.",
          "required" : false,
          "type" : "string"
        },
        "environment" : {
          "description" : "Astra environment.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "PROD"
        },
        "password" : {
          "description" : "DEPRECATED: use secret instead.",
          "required" : false,
          "type" : "string"
        },
        "secret" : {
          "description" : "Astra Token secret to use.",
          "required" : true,
          "type" : "string"
        },
        "secureBundle" : {
          "description" : "Secure bundle of the database. Must be encoded in base64.",
          "required" : false,
          "type" : "string"
        },
        "service" : {
          "description" : "Service type. Set to 'astra'",
          "required" : true,
          "type" : "string"
        },
        "token" : {
          "description" : "Astra Token (AstraCS:xxx) for connecting to the database. If secureBundle is provided, this field is ignored.",
          "required" : false,
          "type" : "string"
        },
        "username" : {
          "description" : "DEPRECATED: use clientId instead.",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "datasource_cassandra" : {
      "type" : "datasource",
      "name" : "Cassandra",
      "description" : "Connect to Apache cassandra.",
      "properties" : {
        "contact-points" : {
          "description" : "Contact points of the cassandra cluster.",
          "required" : true,
          "type" : "string"
        },
        "loadBalancing-localDc" : {
          "description" : "Load balancing local datacenter.",
          "required" : true,
          "type" : "string"
        },
        "password" : {
          "description" : "User password.",
          "required" : false,
          "type" : "string"
        },
        "port" : {
          "description" : "Cassandra port.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "9042"
        },
        "service" : {
          "description" : "Service type. Set to 'cassandra'",
          "required" : true,
          "type" : "string"
        },
        "username" : {
          "description" : "User username.",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "datasource_jdbc" : {
      "type" : "datasource",
      "name" : "JDBC",
      "description" : "Connect to any JDBC compatible database. The driver must be provided as dependency. All the extra configuration properties are passed as is to the JDBC driver.",
      "properties" : {
        "driverClass" : {
          "description" : "JDBC entry-point driver class.",
          "required" : true,
          "type" : "string"
        },
        "service" : {
          "description" : "Service type. Set to 'jdbc'",
          "required" : true,
          "type" : "string"
        },
        "url" : {
          "description" : "JDBC connection url.",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "hugging-face-configuration" : {
      "type" : "hugging-face-configuration",
      "name" : "Hugging Face",
      "description" : "Connect to Hugging Face service.",
      "properties" : {
        "access-key" : {
          "description" : "The access key to use for \"api\" provider.",
          "required" : false,
          "type" : "string"
        },
        "api-url" : {
          "description" : "The URL of the Hugging Face API. Relevant only if provider is \"api\".",
          "required" : false,
          "type" : "string",
          "defaultValue" : "https://api-inference.huggingface.co/pipeline/feature-extraction/"
        },
        "model-check-url" : {
          "description" : "The model url to use. Relevant only if provider is \"api\".",
          "required" : false,
          "type" : "string",
          "defaultValue" : "https://huggingface.co/api/models/"
        },
        "provider" : {
          "description" : "The provider to use. Either \"local\" or \"api\".",
          "required" : false,
          "type" : "string",
          "defaultValue" : "api"
        }
      }
    },
    "open-ai-configuration" : {
      "type" : "open-ai-configuration",
      "name" : "Open AI",
      "description" : "Connect to OpenAI API or Azure OpenAI API.",
      "properties" : {
        "access-key" : {
          "description" : "The access key to use.",
          "required" : true,
          "type" : "string"
        },
        "provider" : {
          "description" : "The provider to use. Either \"openai\" or \"azure\".",
          "required" : false,
          "type" : "string",
          "defaultValue" : "openai"
        },
        "url" : {
          "description" : "Url for Azure OpenAI API. Required only if provider is \"azure\".",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "vector-database_astra" : {
      "type" : "datasource",
      "name" : "Astra",
      "description" : "Connect to DataStax Astra Database service.",
      "properties" : {
        "clientId" : {
          "description" : "Astra Token clientId to use.",
          "required" : true,
          "type" : "string"
        },
        "database" : {
          "description" : "Astra Database name to connect to. If secureBundle is provided, this field is ignored.",
          "required" : false,
          "type" : "string"
        },
        "environment" : {
          "description" : "Astra environment.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "PROD"
        },
        "password" : {
          "description" : "DEPRECATED: use secret instead.",
          "required" : false,
          "type" : "string"
        },
        "secret" : {
          "description" : "Astra Token secret to use.",
          "required" : true,
          "type" : "string"
        },
        "secureBundle" : {
          "description" : "Secure bundle of the database. Must be encoded in base64.",
          "required" : false,
          "type" : "string"
        },
        "service" : {
          "description" : "Service type. Set to 'astra'",
          "required" : true,
          "type" : "string"
        },
        "token" : {
          "description" : "Astra Token (AstraCS:xxx) for connecting to the database. If secureBundle is provided, this field is ignored.",
          "required" : false,
          "type" : "string"
        },
        "username" : {
          "description" : "DEPRECATED: use clientId instead.",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "vector-database_cassandra" : {
      "type" : "datasource",
      "name" : "Cassandra",
      "description" : "Connect to Apache cassandra.",
      "properties" : {
        "contact-points" : {
          "description" : "Contact points of the cassandra cluster.",
          "required" : true,
          "type" : "string"
        },
        "loadBalancing-localDc" : {
          "description" : "Load balancing local datacenter.",
          "required" : true,
          "type" : "string"
        },
        "password" : {
          "description" : "User password.",
          "required" : false,
          "type" : "string"
        },
        "port" : {
          "description" : "Cassandra port.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "9042"
        },
        "service" : {
          "description" : "Service type. Set to 'cassandra'",
          "required" : true,
          "type" : "string"
        },
        "username" : {
          "description" : "User username.",
          "required" : false,
          "type" : "string"
        }
      }
    },
    "vector-database_milvus" : {
      "type" : "vector-database",
      "name" : "Milvus",
      "description" : "Connect to Milvus/Zillis service.",
      "properties" : {
        "host" : {
          "description" : "Host parameter for connecting to Milvus.",
          "required" : false,
          "type" : "string"
        },
        "index-name" : {
          "description" : "Url parameter for connecting to Zillis service.",
          "required" : false,
          "type" : "string"
        },
        "password" : {
          "description" : "Password parameter for connecting to Milvus.",
          "required" : false,
          "type" : "string"
        },
        "port" : {
          "description" : "Port parameter for connecting to Milvus.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "19530"
        },
        "service" : {
          "description" : "Service type. Set to 'milvus'",
          "required" : true,
          "type" : "string"
        },
        "token" : {
          "description" : "Token parameter for connecting to Zillis service.",
          "required" : false,
          "type" : "string"
        },
        "user" : {
          "description" : "User parameter for connecting to Milvus.",
          "required" : false,
          "type" : "string",
          "defaultValue" : "default"
        }
      }
    },
    "vector-database_pinecone" : {
      "type" : "vector-database",
      "name" : "Pinecone",
      "description" : "Connect to Pinecone service.",
      "properties" : {
        "api-key" : {
          "description" : "Api key for connecting to the Pinecone service.",
          "required" : true,
          "type" : "string"
        },
        "endpoint" : {
          "description" : "Endpoint of the Pinecone service.",
          "required" : false,
          "type" : "string"
        },
        "environment" : {
          "description" : "Environment parameter for connecting to the Pinecone service.",
          "required" : true,
          "type" : "string"
        },
        "index-name" : {
          "description" : "Index name parameter for connecting to the Pinecone service.",
          "required" : true,
          "type" : "string"
        },
        "project-name" : {
          "description" : "Project name parameter for connecting to the Pinecone service.",
          "required" : true,
          "type" : "string"
        },
        "server-side-timeout-sec" : {
          "description" : "Server side timeout parameter for connecting to the Pinecone service.",
          "required" : false,
          "type" : "integer",
          "defaultValue" : "10"
        },
        "service" : {
          "description" : "Service type. Set to 'pinecone'",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "vertex-configuration" : {
      "type" : "vertex-configuration",
      "name" : "Vertex AI",
      "description" : "Connect to VertexAI API.",
      "properties" : {
        "project" : {
          "description" : "GCP project name for the Vertex API.",
          "required" : true,
          "type" : "string"
        },
        "region" : {
          "description" : "GCP region for the Vertex API.",
          "required" : true,
          "type" : "string"
        },
        "serviceAccountJson" : {
          "description" : "Specify service account credentials. Refer to the GCP documentation on how to download it",
          "required" : false,
          "type" : "string"
        },
        "token" : {
          "description" : "Access key for the Vertex API.",
          "required" : false,
          "type" : "string"
        },
        "url" : {
          "description" : "URL connection for the Vertex API.",
          "required" : true,
          "type" : "string"
        }
      }
    }
  },
  "assets" : {
    "astra-keyspace" : {
      "name" : "Astra keyspace",
      "description" : "Manage a DataStax Astra keyspace.",
      "properties" : {
        "datasource" : {
          "description" : "Reference to a datasource id configured in the application.",
          "required" : true,
          "type" : "string"
        },
        "keyspace" : {
          "description" : "Name of the keyspace to create.",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "cassandra-keyspace" : {
      "name" : "Cassandra keyspace",
      "description" : "Manage a Cassandra keyspace.",
      "properties" : {
        "create-statements" : {
          "description" : "List of the statement to execute to create the keyspace. They will be executed every time the application is deployed or upgraded.",
          "required" : true,
          "type" : "array",
          "items" : {
            "description" : "List of the statement to execute to create the keyspace. They will be executed every time the application is deployed or upgraded.",
            "required" : true,
            "type" : "string"
          }
        },
        "datasource" : {
          "description" : "Reference to a datasource id configured in the application.",
          "required" : true,
          "type" : "string"
        },
        "delete-statements" : {
          "description" : "List of the statement to execute to cleanup the keyspace. They will be executed when the application is deleted only if 'deletion-mode' is 'delete'.",
          "required" : false,
          "type" : "array",
          "items" : {
            "description" : "List of the statement to execute to cleanup the keyspace. They will be executed when the application is deleted only if 'deletion-mode' is 'delete'.",
            "required" : false,
            "type" : "string"
          }
        },
        "keyspace" : {
          "description" : "Name of the keyspace to create.",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "cassandra-table" : {
      "name" : "Cassandra table",
      "description" : "Manage a Cassandra table in existing keyspace.",
      "properties" : {
        "create-statements" : {
          "description" : "List of the statement to execute to create the table. They will be executed every time the application is deployed or upgraded.",
          "required" : true,
          "type" : "array",
          "items" : {
            "description" : "List of the statement to execute to create the table. They will be executed every time the application is deployed or upgraded.",
            "required" : true,
            "type" : "string"
          }
        },
        "datasource" : {
          "description" : "Reference to a datasource id configured in the application.",
          "required" : true,
          "type" : "string"
        },
        "delete-statements" : {
          "description" : "List of the statement to execute to cleanup the table. They will be executed when the application is deleted only if 'deletion-mode' is 'delete'.",
          "required" : false,
          "type" : "array",
          "items" : {
            "description" : "List of the statement to execute to cleanup the table. They will be executed when the application is deleted only if 'deletion-mode' is 'delete'.",
            "required" : false,
            "type" : "string"
          }
        },
        "keyspace" : {
          "description" : "Name of the keyspace where the table is located.",
          "required" : true,
          "type" : "string"
        },
        "table-name" : {
          "description" : "Name of the table.",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "jdbc-table" : {
      "name" : "JDBC table",
      "description" : "Manage a JDBC table.",
      "properties" : {
        "create-statements" : {
          "description" : "List of the statement to execute to create the table. They will be executed every time the application is deployed or upgraded.",
          "required" : true,
          "type" : "array",
          "items" : {
            "description" : "List of the statement to execute to create the table. They will be executed every time the application is deployed or upgraded.",
            "required" : true,
            "type" : "string"
          }
        },
        "datasource" : {
          "description" : "Reference to a datasource id configured in the application.",
          "required" : true,
          "type" : "string"
        },
        "delete-statements" : {
          "description" : "List of the statement to execute to cleanup the table. They will be executed when the application is deleted only if 'deletion-mode' is 'delete'.",
          "required" : false,
          "type" : "array",
          "items" : {
            "description" : "List of the statement to execute to cleanup the table. They will be executed when the application is deleted only if 'deletion-mode' is 'delete'.",
            "required" : false,
            "type" : "string"
          }
        },
        "table-name" : {
          "description" : "Name of the table.",
          "required" : true,
          "type" : "string"
        }
      }
    },
    "milvus-collection" : {
      "name" : "Milvus collection",
      "description" : "Manage a Milvus collection.",
      "properties" : {
        "collection-name" : {
          "description" : "Name of the collection.",
          "required" : true,
          "type" : "string"
        },
        "create-statements" : {
          "description" : "List of the statement to execute to create the collection. They will be executed every time the application is deployed or upgraded.",
          "required" : true,
          "type" : "array",
          "items" : {
            "description" : "List of the statement to execute to create the collection. They will be executed every time the application is deployed or upgraded.",
            "required" : true,
            "type" : "string"
          }
        },
        "database-name" : {
          "description" : "Name of the database where to create the collection.",
          "required" : false,
          "type" : "string"
        },
        "datasource" : {
          "description" : "Reference to a datasource id configured in the application.",
          "required" : true,
          "type" : "string"
        }
      }
    }
  }
}