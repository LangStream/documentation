<h1> Agents</h1><p>LangStream Version: <strong>0.1.0</strong></p>



<br><h3 data-full-width="true"><a name="ai-chat-completions"></a>Compute chat completions (<code>ai-chat-completions</code>)</h3><p data-full-width="true">Sends the messages to the AI Service to compute chat completions. The result is stored in the specified field.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>ai-service</code></td><td>In case of multiple AI services configured, specify the id of the AI service to use.</td><td>string</td><td></td><td></td></tr><tr><td><code>completion-field</code></td><td>Field to use to store the completion results in the output topic. Use "value" to write the result without a structured schema. Use "value.<field>" to write the result in a specific field.</td><td>string</td><td></td><td></td></tr><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>frequency-penalty</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>log-field</code></td><td>Field to use to store the log of the completion results in the output topic. Use "value" to write the result without a structured schema. Use "value.<field>" to write the result in a specific field.<br>The log contains useful information for debugging the completion prompts.</td><td>string</td><td></td><td></td></tr><tr><td><code>logit-bias</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>object</td><td></td><td></td></tr><tr><td><code>max-tokens</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>integer</td><td></td><td></td></tr><tr><td><code>messages</code></td><td>Messages to use for chat completions. You can use the Mustache syntax.</td><td><a href="#ai-chat-completions.messages">array of object</a></td><td>✓</td><td></td></tr><tr><td><code>min-chunks-per-message</code></td><td>Minimum number of chunks to send to the stream-to-topic topic. The chunks are sent as soon as they are available.<br>The chunks are sent in the order they are received from the AI Service.<br>To improve the TTFB (Time-To-First-Byte), the chunk size starts from 1 and doubles until it reaches the max-chunks-per-message value.</td><td>integer</td><td></td><td>20</td></tr><tr><td><code>model</code></td><td>The model to use for chat completions. The model must be available in the AI Service.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>presence-penalty</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>stop</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>stream</code></td><td>Enable streaming of the results. Use in conjunction with the stream-to-topic parameter.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>stream-response-completion-field</code></td><td>Field to use to store the completion results in the stream-to-topic topic. Use "value" to write the result without a structured schema. Use "value.<field>" to write the result in a specific field.</td><td>string</td><td></td><td></td></tr><tr><td><code>stream-to-topic</code></td><td>Enable streaming of the results. If enabled, the results are streamed to the specified topic in small chunks. The entire messages will be sent to the output topic instead.</td><td>string</td><td></td><td></td></tr><tr><td><code>temperature</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>top-p</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>user</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>string</td><td></td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: "value.first == 'f1' && value.last.toUpperCase() == 'L1'"</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h4 data-full-width="true"><a name="ai-chat-completions.messages"></a>Compute chat completions (<code>ai-chat-completions</code>).messages</h4><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>role</code></td><td>Role of the message. The role is used to identify the speaker in the chat.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>content</code></td><td>Content of the message. You can use the Mustache syntax.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="ai-text-completions"></a>Compute text completions (<code>ai-text-completions</code>)</h3><p data-full-width="true">Sends the text to the AI Service to compute text completions. The result is stored in the specified field.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>ai-service</code></td><td>In case of multiple AI services configured, specify the id of the AI service to use.</td><td>string</td><td></td><td></td></tr><tr><td><code>completion-field</code></td><td>Field to use to store the completion results in the output topic. Use "value" to write the result without a structured schema. Use "value.<field>" to write the result in a specific field.</td><td>string</td><td></td><td></td></tr><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>frequency-penalty</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>log-field</code></td><td>Field to use to store the log of the completion results in the output topic. Use "value" to write the result without a structured schema. Use "value.<field>" to write the result in a specific field.<br>The log contains useful information for debugging the completion prompts.</td><td>string</td><td></td><td></td></tr><tr><td><code>logit-bias</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>object</td><td></td><td></td></tr><tr><td><code>max-tokens</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>integer</td><td></td><td></td></tr><tr><td><code>min-chunks-per-message</code></td><td>Minimum number of chunks to send to the stream-to-topic topic. The chunks are sent as soon as they are available.<br>The chunks are sent in the order they are received from the AI Service.<br>To improve the TTFB (Time-To-First-Byte), the chunk size starts from 1 and doubles until it reaches the max-chunks-per-message value.</td><td>integer</td><td></td><td>20</td></tr><tr><td><code>model</code></td><td>The model to use for text completions. The model must be available in the AI Service.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>presence-penalty</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>prompt</code></td><td>Prompt to use for text completions. You can use the Mustache syntax.</td><td>array of string</td><td>✓</td><td></td></tr><tr><td><code>stop</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>stream</code></td><td>Enable streaming of the results. Use in conjunction with the stream-to-topic parameter.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>stream-response-completion-field</code></td><td>Field to use to store the completion results in the stream-to-topic topic. Use "value" to write the result without a structured schema. Use "value.<field>" to write the result in a specific field.</td><td>string</td><td></td><td></td></tr><tr><td><code>stream-to-topic</code></td><td>Enable streaming of the results. If enabled, the results are streamed to the specified topic in small chunks. The entire messages will be sent to the output topic instead.</td><td>string</td><td></td><td></td></tr><tr><td><code>temperature</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>top-p</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>user</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>string</td><td></td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: "value.first == 'f1' && value.last.toUpperCase() == 'L1'"</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="cast"></a>Cast record to another schema (<code>cast</code>)</h3><p data-full-width="true">Transforms the data to a target compatible schema.<br>Some step operations like cast or compute involve conversions from a type to another. When this happens the rules are:<br>    - timestamp, date and time related object conversions assume UTC time zone if it is not explicit.<br>    - date and time related object conversions to/from STRING use the RFC3339 format.<br>    - timestamp related object conversions to/from LONG and DOUBLE are done using the number of milliseconds since EPOCH (1970-01-01T00:00:00Z).<br>    - date related object conversions to/from INTEGER, LONG, FLOAT and DOUBLE are done using the number of days since EPOCH (1970-01-01).<br>    - time related object conversions to/from INTEGER, LONG and DOUBLE are done using the number of milliseconds since midnight (00:00:00).</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>part</code></td><td>When used with KeyValue data, defines if the transformation is done on the key or on the value. If empty, the transformation applies to both the key and the value.</td><td>string</td><td></td><td></td></tr><tr><td><code>schema-type</code></td><td>The target schema type.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: "value.first == 'f1' && value.last.toUpperCase() == 'L1'"</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="compute"></a>Compute values from the record (<code>compute</code>)</h3><p data-full-width="true">Computes new properties, values or field values based on an expression evaluated at runtime. If the field already exists, it will be overwritten.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>fields</code></td><td>An array of objects describing how to calculate the field values</td><td><a href="#compute.fields">array of object</a></td><td>✓</td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: "value.first == 'f1' && value.last.toUpperCase() == 'L1'"</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h4 data-full-width="true"><a name="compute.fields"></a>Compute values from the record (<code>compute</code>).fields</h4><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>expression</code></td><td>It is evaluated at runtime and the result of the evaluation is assigned to the field.<br>Refer to the language expression documentation for more information on the expression syntax.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>name</code></td><td>The name of the field to be computed. Prefix with key. or value. to compute the fields in the key or value parts of the message.<br>In addition, you can compute values on the following message headers [destinationTopic, messageKey, properties.].<br>Please note that properties is a map of key/value pairs that are referenced by the dot notation, for example properties.key0.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>optional</code></td><td>If true, it marks the field as optional in the schema of the transformed message. This is useful when null is a possible value of the compute expression.</td><td>boolean</td><td></td><td>false</td></tr><tr><td><code>type</code></td><td>The type of the computed field. This<br> will translate to the schema type of the new field in the transformed message.<br> The following types are currently supported :STRING, INT8, INT16, INT32, INT64, FLOAT, DOUBLE, BOOLEAN, DATE, TIME, TIMESTAMP, LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, INSTANT.<br>  The type field is not required for the message headers [destinationTopic, messageKey, properties.] and STRING will be used.<br>  For the value and key, if it is not provided, then the type will be inferred from the result of the expression evaluation.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="compute-ai-embeddings"></a>Compute embeddings of the record (<code>compute-ai-embeddings</code>)</h3><p data-full-width="true">Compute embeddings of the record. The embeddings are stored in the record under a specific field.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>ai-service</code></td><td>In case of multiple AI services configured, specify the id of the AI service to use.</td><td>string</td><td></td><td></td></tr><tr><td><code>arguments</code></td><td>Additional arguments to pass to the AI Service. (HuggingFace only)</td><td>object</td><td></td><td></td></tr><tr><td><code>batch-size</code></td><td>Batch size for submitting the embeddings requests.</td><td>integer</td><td></td><td>10</td></tr><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>concurrency</code></td><td>Max number of concurrent requests to the AI Service.</td><td>integer</td><td></td><td>4</td></tr><tr><td><code>embeddings-field</code></td><td>Field where to store the embeddings.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>flush-interval</code></td><td>Flushing is disabled by default in order to avoid latency spikes.<br>You should enable this feature in the case of background processing.</td><td>integer</td><td></td><td>0</td></tr><tr><td><code>model</code></td><td>Model to use for the embeddings. The model must be available in the configured AI Service.</td><td>string</td><td></td><td>text-embedding-ada-002</td></tr><tr><td><code>modelUrl</code></td><td>URL of the model to use. (HuggingFace only). The default is computed from the model: "djl://ai.djl.huggingface.pytorch{model}"</td><td>string</td><td></td><td></td></tr><tr><td><code>options</code></td><td>Additional options to pass to the AI Service. (HuggingFace only)</td><td>object</td><td></td><td></td></tr><tr><td><code>text</code></td><td>Text to create embeddings from. You can use Mustache syntax to compose multiple fields into a single text. Example:<br>text: "{{{ value.field1 }}} {{{ value.field2 }}}"</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: "value.first == 'f1' && value.last.toUpperCase() == 'L1'"</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="document-to-json"></a>Document to JSON (<code>document-to-json</code>)</h3><p data-full-width="true">Convert raw text document to JSON. The result will be a JSON object with the text content in the specified field.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>copy-properties</code></td><td>Whether to copy the message properties/headers in the output message.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>text-field</code></td><td>Field name to write the text content to.</td><td>string</td><td></td><td>text</td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="drop"></a>Drop the record (<code>drop</code>)</h3><p data-full-width="true">Drops the record from further processing. Use in conjunction with when to selectively drop records.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: "value.first == 'f1' && value.last.toUpperCase() == 'L1'"</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="drop-fields"></a>Drop fields (<code>drop-fields</code>)</h3><p data-full-width="true">Drops the record fields.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>fields</code></td><td>Fields to drop from the input record.</td><td>array of string</td><td>✓</td><td></td></tr><tr><td><code>part</code></td><td>Part to drop. (value or key)</td><td>string</td><td></td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: "value.first == 'f1' && value.last.toUpperCase() == 'L1'"</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="flatten"></a>Flatten record fields (<code>flatten</code>)</h3><p data-full-width="true">Converts structured nested data into a new single-hierarchy-level structured data. The names of the new fields are built by concatenating the intermediate level field names.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>delimiter</code></td><td>The delimiter to use when concatenating the field names.</td><td>string</td><td></td><td>_</td></tr><tr><td><code>part</code></td><td>When used with KeyValue data, defines if the transformation is done on the key or on the value. If empty, the transformation applies to both the key and the value.</td><td>string</td><td></td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: "value.first == 'f1' && value.last.toUpperCase() == 'L1'"</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="identity"></a>Identity function (<code>identity</code>)</h3><p data-full-width="true">Simple agent to move data from the input to the output. Could be used for testing or sample applications.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody></tbody></table>

<br><h3 data-full-width="true"><a name="language-detector"></a>Language detector (<code>language-detector</code>)</h3><p data-full-width="true">Detect the language of a message’s data and limit further processing based on language codes.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>allowedLanguages</code></td><td>Define a list of allowed language codes. If the message language is not in this list, the message is dropped.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>property</code></td><td>The name of the message header to write the language code to.</td><td>string</td><td></td><td>language</td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="merge-key-value"></a>Merge key-value format (<code>merge-key-value</code>)</h3><p data-full-width="true">Merges the fields of KeyValue records where both the key and value are structured types of the same schema type. Only AVRO and JSON are supported.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: "value.first == 'f1' && value.last.toUpperCase() == 'L1'"</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="python-function"></a>Python custom processor (<code>python-function</code>)</h3><p data-full-width="true">Run a your own Python processor.<br>All the configuration properties are available the class init method.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>className</code></td><td>Python class name to instantiate. This class must be present in the application's "python" files.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="python-processor"></a>Python custom processor (<code>python-processor</code>)</h3><p data-full-width="true">Run a your own Python processor.<br>All the configuration properties are available the class init method.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>className</code></td><td>Python class name to instantiate. This class must be present in the application's "python" files.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="python-sink"></a>Python custom sink (<code>python-sink</code>)</h3><p data-full-width="true">Run a your own Python sink.<br>All the configuration properties are available in the class init method.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>className</code></td><td>Python class name to instantiate. This class must be present in the application's "python" files.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="python-source"></a>Python custom source (<code>python-source</code>)</h3><p data-full-width="true">Run a your own Python source.<br>All the configuration properties are available in the class init method.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>className</code></td><td>Python class name to instantiate. This class must be present in the application's "python" files.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="query"></a>Query (<code>query</code>)</h3><p data-full-width="true">Perform a vector search or simple query against a datasource.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>datasource</code></td><td>Reference to a datasource id configured in the application.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>fields</code></td><td>Fields of the record to use as input parameters for the query.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>only-first</code></td><td>If true, only the first result of the query is stored in the output field.</td><td>boolean</td><td></td><td>false</td></tr><tr><td><code>output-field</code></td><td>The name of the field to use to store the query result.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>query</code></td><td>The query to use to extract the data.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: "value.first == 'f1' && value.last.toUpperCase() == 'L1'"</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="query-vector-db"></a>Query a vector database (<code>query-vector-db</code>)</h3><p data-full-width="true">Query a vector database using Vector Search capabilities.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>datasource</code></td><td>Reference to a datasource id configured in the application.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>fields</code></td><td>Fields of the record to use as input parameters for the query.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>only-first</code></td><td>If true, only the first result of the query is stored in the output field.</td><td>boolean</td><td></td><td>false</td></tr><tr><td><code>output-field</code></td><td>The name of the field to use to store the query result.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>query</code></td><td>The query to use to extract the data.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: "value.first == 'f1' && value.last.toUpperCase() == 'L1'"</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="re-rank"></a>Re-rank (<code>re-rank</code>)</h3><p data-full-width="true">Agent for re-ranking documents based on a query.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>algorithm</code></td><td>Algorithm to use for re-ranking. 'none' or 'MMR'.</td><td>string</td><td></td><td>none</td></tr><tr><td><code>b</code></td><td>Parameter for B25 algorithm.</td><td>number</td><td></td><td>0.75</td></tr><tr><td><code>embeddings-field</code></td><td>Result field for the embeddings.</td><td>string</td><td></td><td></td></tr><tr><td><code>field</code></td><td>The field that contains the documents to sort.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>k1</code></td><td>Parameter for B25 algorithm.</td><td>number</td><td></td><td>1.5</td></tr><tr><td><code>lambda</code></td><td>Parameter for MMR algorithm.</td><td>number</td><td></td><td>0.5</td></tr><tr><td><code>max</code></td><td>Maximum number of documents to keep.</td><td>integer</td><td></td><td>100</td></tr><tr><td><code>output-field</code></td><td>The field that will hold the results, it can be the same as "field" to override it.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>query-embeddings</code></td><td>Field that contains the embeddings of the documents to sort.</td><td>string</td><td></td><td></td></tr><tr><td><code>query-text</code></td><td>Field that already contains the text that has been embedded.</td><td>string</td><td></td><td></td></tr><tr><td><code>text-field</code></td><td>Result field for the text.</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="s3-source"></a>S3 Source (<code>s3-source</code>)</h3><p data-full-width="true">Reads data from S3 bucket</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>access-key</code></td><td>Access key for the S3 server.</td><td>string</td><td></td><td>minioadmin</td></tr><tr><td><code>bucketName</code></td><td>The name of the bucket to read from.</td><td>string</td><td></td><td>langstream-source</td></tr><tr><td><code>endpoint</code></td><td>The endpoint of the S3 server.</td><td>string</td><td></td><td>http://minio-endpoint.-not-set:9090</td></tr><tr><td><code>file-extensions</code></td><td>Comma separated list of file extensions to filter by.</td><td>string</td><td></td><td>pdf,docx,html,htm,md,txt</td></tr><tr><td><code>idle-time</code></td><td>Region for the S3 server.</td><td>integer</td><td></td><td>5</td></tr><tr><td><code>region</code></td><td>Region for the S3 server.</td><td>string</td><td></td><td></td></tr><tr><td><code>secret-key</code></td><td>Secret key for the S3 server.</td><td>string</td><td></td><td>minioadmin</td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="sink"></a>Kafka Connect Sink agent (<code>sink</code>)</h3><p data-full-width="true">Run any Kafka Connect Sink.<br>    All the configuration properties are passed to the Kafka Connect Sink.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>connector.class</code></td><td>Java main class for the Kafka Sink connector.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="source"></a>Kafka Connect Source agent (<code>source</code>)</h3><p data-full-width="true">Run any Kafka Connect Source.<br>    All the configuration properties are passed to the Kafka Connect Source.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>connector.class</code></td><td>Java main class for the Kafka Source connector.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="text-extractor"></a>Text extractor (<code>text-extractor</code>)</h3><p data-full-width="true">Extracts text content from different document formats like PDF, JSON, XML, ODF, HTML and many others.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody></tbody></table>

<br><h3 data-full-width="true"><a name="text-normaliser"></a>Text normaliser (<code>text-normaliser</code>)</h3><p data-full-width="true">Apply normalisation to the text.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>make-lowercase</code></td><td>Whether to make the text lowercase.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>trim-spaces</code></td><td>Whether to trim spaces from the text.</td><td>boolean</td><td></td><td>true</td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="text-splitter"></a>Text splitter (<code>text-splitter</code>)</h3><p data-full-width="true">Split message content in chunks.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>chunk_overlap</code></td><td>RecursiveCharacterTextSplitter splitter option. Chunk overlap of the previous message.<br>Checkout https://github.com/knuddelsgmbh/jtokkit for more details.</td><td>integer</td><td></td><td>100</td></tr><tr><td><code>chunk_size</code></td><td>RecursiveCharacterTextSplitter splitter option. Chunk size of each message.<br>Checkout https://github.com/knuddelsgmbh/jtokkit for more details.</td><td>integer</td><td></td><td>200</td></tr><tr><td><code>keep_separator</code></td><td>RecursiveCharacterTextSplitter splitter option. Whether or not to keep separators.<br>Checkout https://github.com/knuddelsgmbh/jtokkit for more details.</td><td>boolean</td><td></td><td>false</td></tr><tr><td><code>length_function</code></td><td>RecursiveCharacterTextSplitter splitter option. Options are: r50k_base, p50k_base, p50k_edit and cl100k_base.<br>Checkout https://github.com/knuddelsgmbh/jtokkit for more details.</td><td>string</td><td></td><td>cl100k_base</td></tr><tr><td><code>separators</code></td><td>RecursiveCharacterTextSplitter splitter option. The separator to use for splitting.<br>Checkout https://github.com/knuddelsgmbh/jtokkit for more details.</td><td>array of string</td><td></td><td>"\n\n", "\n", " ", ""</td></tr><tr><td><code>splitter_type</code></td><td>Splitter implementation to use. Currently supported: RecursiveCharacterTextSplitter.</td><td>string</td><td></td><td>RecursiveCharacterTextSplitter</td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="unwrap-key-value"></a>Unwrap key-value format (<code>unwrap-key-value</code>)</h3><p data-full-width="true">If the record value is in KeyValue format, extracts the KeyValue's key or value and make it the record value.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>unwrapKey</code></td><td>Whether to unwrap the key instead of the value.</td><td>boolean</td><td></td><td>false</td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: "value.first == 'f1' && value.last.toUpperCase() == 'L1'"</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="vector-db-sink"></a>Vector database sink (<code>vector-db-sink</code>)</h3><p data-full-width="true">Store vectors in a vector database.<br>Configuration properties depends on the vector database implementation, specified by the "datasource" property.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>datasource</code></td><td>The defined datasource ID to use to store the vectors.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="webcrawler-source"></a>Web crawler source (<code>webcrawler-source</code>)</h3><p data-full-width="true">Crawl a website and extract the content of the pages.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>access-key</code></td><td>Configuration for handling the agent status.<br>Access key for the S3 server.</td><td>string</td><td></td><td>minioadmin</td></tr><tr><td><code>allowed-domains</code></td><td>Domains that the crawler is allowed to access.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>bucketName</code></td><td>Configuration for handling the agent status.<br>The name of the bucket.</td><td>string</td><td></td><td>langstream-source</td></tr><tr><td><code>endpoint</code></td><td>Configuration for handling the agent status.<br>The S3 endpoint.</td><td>string</td><td></td><td>http://minio-endpoint.-not-set:9090</td></tr><tr><td><code>forbidden-paths</code></td><td>Paths that the crawler is not allowed to access.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>handle-cookies</code></td><td>Whether to handle cookies.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>handle-robots-file</code></td><td>Whether to scan the HTML documents to find links to other pages.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>http-timeout</code></td><td>Timeout for HTTP requests. (in milliseconds)</td><td>integer</td><td></td><td>10000</td></tr><tr><td><code>max-depth</code></td><td>Maximum depth of the crawl.</td><td>integer</td><td></td><td>50</td></tr><tr><td><code>max-error-count</code></td><td>Maximum number of errors allowed before stopping.</td><td>integer</td><td></td><td>5</td></tr><tr><td><code>max-unflushed-pages</code></td><td>Maximum number of unflushed pages before the agent persists the crawl data.</td><td>integer</td><td></td><td>100</td></tr><tr><td><code>max-urls</code></td><td>Maximum number of URLs that can be crawled.</td><td>integer</td><td></td><td>1000</td></tr><tr><td><code>min-time-between-requests</code></td><td>Minimum time between two requests to the same domain. (in milliseconds)</td><td>integer</td><td></td><td>500</td></tr><tr><td><code>region</code></td><td>Configuration for handling the agent status.<br>Region for the S3 server.</td><td>string</td><td></td><td></td></tr><tr><td><code>reindex-interval-seconds</code></td><td>Time interval between reindexing of the pages.</td><td>integer</td><td></td><td>86400</td></tr><tr><td><code>scan-html-documents</code></td><td>Whether to scan HTML documents for links to other sites.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>secret-key</code></td><td>Configuration for handling the agent status.<br>Secret key for the S3 server.</td><td>string</td><td></td><td>minioadmin</td></tr><tr><td><code>seed-urls</code></td><td>The starting URLs for the crawl.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>user-agent</code></td><td>User agent to use for the requests.</td><td>string</td><td></td><td>Mozilla/5.0 (compatible; LangStream.ai/0.1; +https://langstream.ai)</td></tr></tbody></table>



