<h1>Agents</h1><p>LangStream Version: <strong>0.3.0</strong></p>



<br><h2 data-full-width="true"><a name="ai-chat-completions"></a>Compute chat completions (<code>ai-chat-completions</code>)</h2><p data-full-width="true">Sends the messages to the AI Service to compute chat completions. The result is stored in the specified field.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>ai-service</code></td><td>In case of multiple AI services configured, specify the id of the AI service to use.</td><td>string</td><td></td><td></td></tr><tr><td><code>completion-field</code></td><td>Field to use to store the completion results in the output topic. Use &quot;value&quot; to write the result without a structured schema. Use &quot;value.&lt;field&gt;&quot; to write the result in a specific field.</td><td>string</td><td></td><td></td></tr><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>frequency-penalty</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>log-field</code></td><td>Field to use to store the log of the completion results in the output topic. Use &quot;value&quot; to write the result without a structured schema. Use &quot;value.&lt;field&gt;&quot; to write the result in a specific field.<br>The log contains useful information for debugging the completion prompts.</td><td>string</td><td></td><td></td></tr><tr><td><code>logit-bias</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>object</td><td></td><td></td></tr><tr><td><code>max-tokens</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>integer</td><td></td><td></td></tr><tr><td><code>messages</code></td><td>Messages to use for chat completions. You can use the Mustache syntax.</td><td><a href="#ai-chat-completions.messages">array of object</a></td><td>✓</td><td></td></tr><tr><td><code>min-chunks-per-message</code></td><td>Minimum number of chunks to send to the stream-to-topic topic. The chunks are sent as soon as they are available.<br>The chunks are sent in the order they are received from the AI Service.<br>To improve the TTFB (Time-To-First-Byte), the chunk size starts from 1 and doubles until it reaches the max-chunks-per-message value.</td><td>integer</td><td></td><td>20</td></tr><tr><td><code>model</code></td><td>The model to use for chat completions. The model must be available in the AI Service.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>options</code></td><td>Additional options for the model configuration. The structure depends on the model and AI provider.</td><td>object</td><td></td><td></td></tr><tr><td><code>presence-penalty</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>stop</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>stream</code></td><td>Enable streaming of the results. Use in conjunction with the stream-to-topic parameter.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>stream-response-completion-field</code></td><td>Field to use to store the completion results in the stream-to-topic topic. Use &quot;value&quot; to write the result without a structured schema. Use &quot;value.&lt;field&gt;&quot; to write the result in a specific field.</td><td>string</td><td></td><td></td></tr><tr><td><code>stream-to-topic</code></td><td>Enable streaming of the results. If enabled, the results are streamed to the specified topic in small chunks. The entire messages will be sent to the output topic instead.</td><td>string</td><td></td><td></td></tr><tr><td><code>temperature</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>top-p</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>user</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>string</td><td></td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: &quot;value.first == &#x27;f1&#x27; &amp;&amp; value.last.toUpperCase() == &#x27;L1&#x27;&quot;</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="ai-chat-completions.messages"></a>Compute chat completions (<code>ai-chat-completions</code>).messages</h3><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>role</code></td><td>Role of the message. The role is used to identify the speaker in the chat.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>content</code></td><td>Content of the message. You can use the Mustache syntax.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="ai-text-completions"></a>Compute text completions (<code>ai-text-completions</code>)</h2><p data-full-width="true">Sends the text to the AI Service to compute text completions. The result is stored in the specified field.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>ai-service</code></td><td>In case of multiple AI services configured, specify the id of the AI service to use.</td><td>string</td><td></td><td></td></tr><tr><td><code>completion-field</code></td><td>Field to use to store the completion results in the output topic. Use &quot;value&quot; to write the result without a structured schema. Use &quot;value.&lt;field&gt;&quot; to write the result in a specific field.</td><td>string</td><td></td><td></td></tr><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>frequency-penalty</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>log-field</code></td><td>Field to use to store the log of the completion results in the output topic. Use &quot;value&quot; to write the result without a structured schema. Use &quot;value.&lt;field&gt;&quot; to write the result in a specific field.<br>The log contains useful information for debugging the completion prompts.</td><td>string</td><td></td><td></td></tr><tr><td><code>logit-bias</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>object</td><td></td><td></td></tr><tr><td><code>logprobs</code></td><td>Logprobs parameter (only valid for OpenAI).</td><td>string</td><td></td><td></td></tr><tr><td><code>logprobs-field</code></td><td>Log probabilities to a field.</td><td>string</td><td></td><td></td></tr><tr><td><code>max-tokens</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>integer</td><td></td><td></td></tr><tr><td><code>min-chunks-per-message</code></td><td>Minimum number of chunks to send to the stream-to-topic topic. The chunks are sent as soon as they are available.<br>The chunks are sent in the order they are received from the AI Service.<br>To improve the TTFB (Time-To-First-Byte), the chunk size starts from 1 and doubles until it reaches the max-chunks-per-message value.</td><td>integer</td><td></td><td>20</td></tr><tr><td><code>model</code></td><td>The model to use for text completions. The model must be available in the AI Service.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>options</code></td><td>Additional options for the model configuration. The structure depends on the model and AI provider.</td><td>object</td><td></td><td></td></tr><tr><td><code>presence-penalty</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>prompt</code></td><td>Prompt to use for text completions. You can use the Mustache syntax.</td><td>array of string</td><td>✓</td><td></td></tr><tr><td><code>stop</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>stream</code></td><td>Enable streaming of the results. Use in conjunction with the stream-to-topic parameter.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>stream-response-completion-field</code></td><td>Field to use to store the completion results in the stream-to-topic topic. Use &quot;value&quot; to write the result without a structured schema. Use &quot;value.&lt;field&gt;&quot; to write the result in a specific field.</td><td>string</td><td></td><td></td></tr><tr><td><code>stream-to-topic</code></td><td>Enable streaming of the results. If enabled, the results are streamed to the specified topic in small chunks. The entire messages will be sent to the output topic instead.</td><td>string</td><td></td><td></td></tr><tr><td><code>temperature</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>top-p</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>number</td><td></td><td></td></tr><tr><td><code>user</code></td><td>Parameter for the completion request. The parameters are passed to the AI Service as is.</td><td>string</td><td></td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: &quot;value.first == &#x27;f1&#x27; &amp;&amp; value.last.toUpperCase() == &#x27;L1&#x27;&quot;</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="azure-blob-storage-source"></a>Azure Blob Storage Source (<code>azure-blob-storage-source</code>)</h2><p data-full-width="true">Reads data from Azure blobs. There are three supported ways to authenticate:<br>- SAS token<br>- Storage account name and key<br>- Storage account connection string</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>container</code></td><td>The name of the Azure econtainer to read from.</td><td>string</td><td></td><td>langstream-azure-source</td></tr><tr><td><code>endpoint</code></td><td>Endpoint to connect to. Usually it&#x27;s https://&lt;storage-account&gt;.blob.core.windows.net.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>file-extensions</code></td><td>Comma separated list of file extensions to filter by.</td><td>string</td><td></td><td>pdf,docx,html,htm,md,txt</td></tr><tr><td><code>idle-time</code></td><td>Time in seconds to sleep after polling for new files.</td><td>integer</td><td></td><td>5</td></tr><tr><td><code>sas-token</code></td><td>Azure SAS token. If not provided, storage account name and key must be provided.</td><td>string</td><td></td><td></td></tr><tr><td><code>storage-account-connection-string</code></td><td>Azure storage account connection string. If not provided, SAS token must be provided.</td><td>string</td><td></td><td></td></tr><tr><td><code>storage-account-key</code></td><td>Azure storage account key. If not provided, SAS token must be provided.</td><td>string</td><td></td><td></td></tr><tr><td><code>storage-account-name</code></td><td>Azure storage account name. If not provided, SAS token must be provided.</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="cast"></a>Cast record to another schema (<code>cast</code>)</h2><p data-full-width="true">Transforms the data to a target compatible schema.<br>Some step operations like cast or compute involve conversions from a type to another. When this happens the rules are:<br>    - timestamp, date and time related object conversions assume UTC time zone if it is not explicit.<br>    - date and time related object conversions to/from STRING use the RFC3339 format.<br>    - timestamp related object conversions to/from LONG and DOUBLE are done using the number of milliseconds since EPOCH (1970-01-01T00:00:00Z).<br>    - date related object conversions to/from INTEGER, LONG, FLOAT and DOUBLE are done using the number of days since EPOCH (1970-01-01).<br>    - time related object conversions to/from INTEGER, LONG and DOUBLE are done using the number of milliseconds since midnight (00:00:00).</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>part</code></td><td>When used with KeyValue data, defines if the transformation is done on the key or on the value. If empty, the transformation applies to both the key and the value.</td><td>string</td><td></td><td></td></tr><tr><td><code>schema-type</code></td><td>The target schema type.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: &quot;value.first == &#x27;f1&#x27; &amp;&amp; value.last.toUpperCase() == &#x27;L1&#x27;&quot;</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="compute"></a>Compute values from the record (<code>compute</code>)</h2><p data-full-width="true">Computes new properties, values or field values based on an expression evaluated at runtime. If the field already exists, it will be overwritten.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>fields</code></td><td>An array of objects describing how to calculate the field values</td><td><a href="#compute.fields">array of object</a></td><td>✓</td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: &quot;value.first == &#x27;f1&#x27; &amp;&amp; value.last.toUpperCase() == &#x27;L1&#x27;&quot;</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="compute.fields"></a>Compute values from the record (<code>compute</code>).fields</h3><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>expression</code></td><td>It is evaluated at runtime and the result of the evaluation is assigned to the field.<br>Refer to the language expression documentation for more information on the expression syntax.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>name</code></td><td>The name of the field to be computed. Prefix with key. or value. to compute the fields in the key or value parts of the message.<br>In addition, you can compute values on the following message headers [destinationTopic, messageKey, properties.].<br>Please note that properties is a map of key/value pairs that are referenced by the dot notation, for example properties.key0.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>optional</code></td><td>If true, it marks the field as optional in the schema of the transformed message. This is useful when null is a possible value of the compute expression.</td><td>boolean</td><td></td><td>false</td></tr><tr><td><code>type</code></td><td>The type of the computed field. This<br> will translate to the schema type of the new field in the transformed message.<br> The following types are currently supported :STRING, INT8, INT16, INT32, INT64, FLOAT, DOUBLE, BOOLEAN, DATE, TIME, TIMESTAMP, LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, INSTANT.<br>  The type field is not required for the message headers [destinationTopic, messageKey, properties.] and STRING will be used.<br>  For the value and key, if it is not provided, then the type will be inferred from the result of the expression evaluation.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="compute-ai-embeddings"></a>Compute embeddings of the record (<code>compute-ai-embeddings</code>)</h2><p data-full-width="true">Compute embeddings of the record. The embeddings are stored in the record under a specific field.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>ai-service</code></td><td>In case of multiple AI services configured, specify the id of the AI service to use.</td><td>string</td><td></td><td></td></tr><tr><td><code>arguments</code></td><td>Additional arguments to pass to the AI Service. (HuggingFace only)</td><td>object</td><td></td><td></td></tr><tr><td><code>batch-size</code></td><td>Batch size for submitting the embeddings requests.</td><td>integer</td><td></td><td>10</td></tr><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>concurrency</code></td><td>Max number of concurrent requests to the AI Service.</td><td>integer</td><td></td><td>4</td></tr><tr><td><code>embeddings-field</code></td><td>Field where to store the embeddings.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>flush-interval</code></td><td>Flushing is disabled by default in order to avoid latency spikes.<br>You should enable this feature in the case of background processing.</td><td>integer</td><td></td><td>0</td></tr><tr><td><code>loop-over</code></td><td>Execute the agent over a list of documents</td><td>string</td><td></td><td></td></tr><tr><td><code>model</code></td><td>Model to use for the embeddings. The model must be available in the configured AI Service.</td><td>string</td><td></td><td>text-embedding-ada-002</td></tr><tr><td><code>model-url</code></td><td>URL of the model to use. (HuggingFace only). The default is computed from the model: &quot;djl://ai.djl.huggingface.pytorch/{model}&quot;</td><td>string</td><td></td><td></td></tr><tr><td><code>options</code></td><td>Additional options to pass to the AI Service. (HuggingFace only)</td><td>object</td><td></td><td></td></tr><tr><td><code>text</code></td><td>Text to create embeddings from. You can use Mustache syntax to compose multiple fields into a single text. Example:<br>text: &quot;{{{ value.field1 }}} {{{ value.field2 }}}&quot;</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: &quot;value.first == &#x27;f1&#x27; &amp;&amp; value.last.toUpperCase() == &#x27;L1&#x27;&quot;</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="dispatch"></a>Dispatch agent (<code>dispatch</code>)</h2><p data-full-width="true">Dispatches messages to different destinations based on conditions.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>routes</code></td><td>Routes.</td><td><a href="#dispatch.routes">array of object</a></td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="dispatch.routes"></a>Dispatch agent (<code>dispatch</code>).routes</h3><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>destination</code></td><td>Destination of the message.</td><td>string</td><td></td><td></td></tr><tr><td><code>action</code></td><td>Action on the message. Possible values are &quot;dispatch&quot; or &quot;drop&quot;.</td><td>string</td><td></td><td>dispatch</td></tr><tr><td><code>when</code></td><td>Condition to activate the route. This is a standard EL expression.</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="document-to-json"></a>Document to JSON (<code>document-to-json</code>)</h2><p data-full-width="true">Convert raw text document to JSON. The result will be a JSON object with the text content in the specified field.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>copy-properties</code></td><td>Whether to copy the message properties/headers in the output message.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>text-field</code></td><td>Field name to write the text content to.</td><td>string</td><td></td><td>text</td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="drop"></a>Drop the record (<code>drop</code>)</h2><p data-full-width="true">Drops the record from further processing. Use in conjunction with when to selectively drop records.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: &quot;value.first == &#x27;f1&#x27; &amp;&amp; value.last.toUpperCase() == &#x27;L1&#x27;&quot;</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="drop-fields"></a>Drop fields (<code>drop-fields</code>)</h2><p data-full-width="true">Drops the record fields.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>fields</code></td><td>Fields to drop from the input record.</td><td>array of string</td><td>✓</td><td></td></tr><tr><td><code>part</code></td><td>Part to drop. (value or key)</td><td>string</td><td></td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: &quot;value.first == &#x27;f1&#x27; &amp;&amp; value.last.toUpperCase() == &#x27;L1&#x27;&quot;</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="flare-controller"></a>Flare Controller (<code>flare-controller</code>)</h2><p data-full-width="true">Apply to the Flare pattern to enhance the quality of text completion results.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>logprobs-field</code></td><td>The field that contains the logprobs of tokens returned by the ai-text-completion agent.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>loop-topic</code></td><td>Name of the topic to forward the message in case of requesting more documents.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>retrieve-documents-field</code></td><td>Name of the field to set in order to request the retrival of more documents.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>tokens-field</code></td><td>The field that contains the list of tokens returned by the ai-text-completion agent.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="flatten"></a>Flatten record fields (<code>flatten</code>)</h2><p data-full-width="true">Converts structured nested data into a new single-hierarchy-level structured data. The names of the new fields are built by concatenating the intermediate level field names.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>delimiter</code></td><td>The delimiter to use when concatenating the field names.</td><td>string</td><td></td><td>_</td></tr><tr><td><code>part</code></td><td>When used with KeyValue data, defines if the transformation is done on the key or on the value. If empty, the transformation applies to both the key and the value.</td><td>string</td><td></td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: &quot;value.first == &#x27;f1&#x27; &amp;&amp; value.last.toUpperCase() == &#x27;L1&#x27;&quot;</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="http-request"></a>Http Request (<code>http-request</code>)</h2><p data-full-width="true">Agent for enriching data with an HTTP request.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>allow-redirects</code></td><td>Whether or not to follow redirects.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>body</code></td><td>Body to send with the request. You can use the Mustache syntax to inject value from the context.</td><td>string</td><td></td><td></td></tr><tr><td><code>handle-cookies</code></td><td>Whether or not to handle cookies during the redirects.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>headers</code></td><td>Headers to send with the request. You can use the Mustache syntax to inject value from the context.</td><td>object</td><td></td><td></td></tr><tr><td><code>method</code></td><td>Http method to use for the request.</td><td>string</td><td></td><td>GET</td></tr><tr><td><code>output-field</code></td><td>The field that will hold the results, it can be the same as &quot;field&quot; to override it.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>query-string</code></td><td>Query string to append to the url. You can use the Mustache syntax to inject value from the context.<br>Note that the values will be automatically escaped.</td><td>object</td><td></td><td></td></tr><tr><td><code>url</code></td><td>Url to send the request to. For adding query string parameters, use the `query-string` field.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="identity"></a>Identity function (<code>identity</code>)</h2><p data-full-width="true">Simple agent to move data from the input to the output. Could be used for testing or sample applications.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody></tbody></table>

<br><h2 data-full-width="true"><a name="language-detector"></a>Language detector (<code>language-detector</code>)</h2><p data-full-width="true">Detect the language of a message’s data and limit further processing based on language codes.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>allowedLanguages</code></td><td>Define a list of allowed language codes. If the message language is not in this list, the message is dropped.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>property</code></td><td>The name of the message header to write the language code to.</td><td>string</td><td></td><td>language</td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="log-event"></a>Log an event (<code>log-event</code>)</h2><p data-full-width="true">Log a line in the agent logs when a record is received.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>fields</code></td><td>Fields to log.</td><td><a href="#log-event.fields">array of object</a></td><td></td><td></td></tr><tr><td><code>when</code></td><td>Condition to trigger the operation. This is a standard EL expression.</td><td>string</td><td></td><td>true</td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="log-event.fields"></a>Log an event (<code>log-event</code>).fields</h3><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>expression</code></td><td>Expression to compute the value of the field. This is a standard EL expression.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>name</code></td><td>Name of the field like value.xx, key.xxx, properties.xxx</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="merge-key-value"></a>Merge key-value format (<code>merge-key-value</code>)</h2><p data-full-width="true">Merges the fields of KeyValue records where both the key and value are structured types of the same schema type. Only AVRO and JSON are supported.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: &quot;value.first == &#x27;f1&#x27; &amp;&amp; value.last.toUpperCase() == &#x27;L1&#x27;&quot;</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="python-function"></a>Python custom processor (<code>python-function</code>)</h2><p data-full-width="true">Run a your own Python processor.<br>All the configuration properties are available the class init method.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>className</code></td><td>Python class name to instantiate. This class must be present in the application&#x27;s &quot;python&quot; files.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="python-processor"></a>Python custom processor (<code>python-processor</code>)</h2><p data-full-width="true">Run a your own Python processor.<br>All the configuration properties are available the class init method.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>className</code></td><td>Python class name to instantiate. This class must be present in the application&#x27;s &quot;python&quot; files.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="python-sink"></a>Python custom sink (<code>python-sink</code>)</h2><p data-full-width="true">Run a your own Python sink.<br>All the configuration properties are available in the class init method.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>className</code></td><td>Python class name to instantiate. This class must be present in the application&#x27;s &quot;python&quot; files.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="python-source"></a>Python custom source (<code>python-source</code>)</h2><p data-full-width="true">Run a your own Python source.<br>All the configuration properties are available in the class init method.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>className</code></td><td>Python class name to instantiate. This class must be present in the application&#x27;s &quot;python&quot; files.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="query"></a>Query (<code>query</code>)</h2><p data-full-width="true">Perform a vector search or simple query against a datasource.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>datasource</code></td><td>Reference to a datasource id configured in the application.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>fields</code></td><td>Fields of the record to use as input parameters for the query.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>generated-keys</code></td><td>List of fields to use as generated keys. The generated keys are returned in the output, depending on the database.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>loop-over</code></td><td>Loop over a list of items taken from the record. For instance value.documents.<br>It must refer to a list of maps. In this case the output-field parameter<br>but be like &quot;record.fieldname&quot; in order to replace or set a field in each record<br>with the results of the query. In the query parameters you can refer to the<br>record fields using &quot;record.field&quot;.</td><td>string</td><td></td><td></td></tr><tr><td><code>mode</code></td><td>Execution mode: query or execute. In query mode, the query is executed and the results are returned. In execute mode, the query is executed and the result is the number of rows affected (depending on the database).</td><td>string</td><td></td><td>query</td></tr><tr><td><code>only-first</code></td><td>If true, only the first result of the query is stored in the output field.</td><td>boolean</td><td></td><td>false</td></tr><tr><td><code>output-field</code></td><td>The name of the field to use to store the query result.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>query</code></td><td>The query to use to extract the data.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: &quot;value.first == &#x27;f1&#x27; &amp;&amp; value.last.toUpperCase() == &#x27;L1&#x27;&quot;</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="query-vector-db"></a>Query a vector database (<code>query-vector-db</code>)</h2><p data-full-width="true">Query a vector database using Vector Search capabilities.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>datasource</code></td><td>Reference to a datasource id configured in the application.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>fields</code></td><td>Fields of the record to use as input parameters for the query.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>generated-keys</code></td><td>List of fields to use as generated keys. The generated keys are returned in the output, depending on the database.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>loop-over</code></td><td>Loop over a list of items taken from the record. For instance value.documents.<br>It must refer to a list of maps. In this case the output-field parameter<br>but be like &quot;record.fieldname&quot; in order to replace or set a field in each record<br>with the results of the query. In the query parameters you can refer to the<br>record fields using &quot;record.field&quot;.</td><td>string</td><td></td><td></td></tr><tr><td><code>mode</code></td><td>Execution mode: query or execute. In query mode, the query is executed and the results are returned. In execute mode, the query is executed and the result is the number of rows affected (depending on the database).</td><td>string</td><td></td><td>query</td></tr><tr><td><code>only-first</code></td><td>If true, only the first result of the query is stored in the output field.</td><td>boolean</td><td></td><td>false</td></tr><tr><td><code>output-field</code></td><td>The name of the field to use to store the query result.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>query</code></td><td>The query to use to extract the data.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: &quot;value.first == &#x27;f1&#x27; &amp;&amp; value.last.toUpperCase() == &#x27;L1&#x27;&quot;</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="re-rank"></a>Re-rank (<code>re-rank</code>)</h2><p data-full-width="true">Agent for re-ranking documents based on a query.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>algorithm</code></td><td>Algorithm to use for re-ranking. &#x27;none&#x27; or &#x27;MMR&#x27;.</td><td>string</td><td></td><td>none</td></tr><tr><td><code>b</code></td><td>Parameter for B25 algorithm.</td><td>number</td><td></td><td>0.75</td></tr><tr><td><code>embeddings-field</code></td><td>Result field for the embeddings.</td><td>string</td><td></td><td></td></tr><tr><td><code>field</code></td><td>The field that contains the documents to sort.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>k1</code></td><td>Parameter for B25 algorithm.</td><td>number</td><td></td><td>1.5</td></tr><tr><td><code>lambda</code></td><td>Parameter for MMR algorithm.</td><td>number</td><td></td><td>0.5</td></tr><tr><td><code>max</code></td><td>Maximum number of documents to keep.</td><td>integer</td><td></td><td>100</td></tr><tr><td><code>output-field</code></td><td>The field that will hold the results, it can be the same as &quot;field&quot; to override it.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>query-embeddings</code></td><td>Field that contains the embeddings of the documents to sort.</td><td>string</td><td></td><td></td></tr><tr><td><code>query-text</code></td><td>Field that already contains the text that has been embedded.</td><td>string</td><td></td><td></td></tr><tr><td><code>text-field</code></td><td>Result field for the text.</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="s3-source"></a>S3 Source (<code>s3-source</code>)</h2><p data-full-width="true">Reads data from S3 bucket</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>access-key</code></td><td>Access key for the S3 server.</td><td>string</td><td></td><td>minioadmin</td></tr><tr><td><code>bucketName</code></td><td>The name of the bucket to read from.</td><td>string</td><td></td><td>langstream-source</td></tr><tr><td><code>endpoint</code></td><td>The endpoint of the S3 server.</td><td>string</td><td></td><td>http://minio-endpoint.-not-set:9090</td></tr><tr><td><code>file-extensions</code></td><td>Comma separated list of file extensions to filter by.</td><td>string</td><td></td><td>pdf,docx,html,htm,md,txt</td></tr><tr><td><code>idle-time</code></td><td>Time in seconds to sleep after polling for new files.</td><td>integer</td><td></td><td>5</td></tr><tr><td><code>region</code></td><td>Region for the S3 server.</td><td>string</td><td></td><td></td></tr><tr><td><code>secret-key</code></td><td>Secret key for the S3 server.</td><td>string</td><td></td><td>minioadmin</td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="sink"></a>Kafka Connect Sink agent (<code>sink</code>)</h2><p data-full-width="true">Run any Kafka Connect Sink.<br>    All the configuration properties are passed to the Kafka Connect Sink.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>connector.class</code></td><td>Java main class for the Kafka Sink connector.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="source"></a>Kafka Connect Source agent (<code>source</code>)</h2><p data-full-width="true">Run any Kafka Connect Source.<br>    All the configuration properties are passed to the Kafka Connect Source.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>connector.class</code></td><td>Java main class for the Kafka Source connector.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="text-extractor"></a>Text extractor (<code>text-extractor</code>)</h2><p data-full-width="true">Extracts text content from different document formats like PDF, JSON, XML, ODF, HTML and many others.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody></tbody></table>

<br><h2 data-full-width="true"><a name="text-normaliser"></a>Text normaliser (<code>text-normaliser</code>)</h2><p data-full-width="true">Apply normalisation to the text.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>make-lowercase</code></td><td>Whether to make the text lowercase.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>trim-spaces</code></td><td>Whether to trim spaces from the text.</td><td>boolean</td><td></td><td>true</td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="text-splitter"></a>Text splitter (<code>text-splitter</code>)</h2><p data-full-width="true">Split message content in chunks.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>chunk_overlap</code></td><td>RecursiveCharacterTextSplitter splitter option. Chunk overlap of the previous message.<br>Checkout https://github.com/knuddelsgmbh/jtokkit for more details.</td><td>integer</td><td></td><td>100</td></tr><tr><td><code>chunk_size</code></td><td>RecursiveCharacterTextSplitter splitter option. Chunk size of each message.<br>Checkout https://github.com/knuddelsgmbh/jtokkit for more details.</td><td>integer</td><td></td><td>200</td></tr><tr><td><code>keep_separator</code></td><td>RecursiveCharacterTextSplitter splitter option. Whether or not to keep separators.<br>Checkout https://github.com/knuddelsgmbh/jtokkit for more details.</td><td>boolean</td><td></td><td>false</td></tr><tr><td><code>length_function</code></td><td>RecursiveCharacterTextSplitter splitter option. Options are: r50k_base, p50k_base, p50k_edit and cl100k_base.<br>Checkout https://github.com/knuddelsgmbh/jtokkit for more details.</td><td>string</td><td></td><td>cl100k_base</td></tr><tr><td><code>separators</code></td><td>RecursiveCharacterTextSplitter splitter option. The separator to use for splitting.<br>Checkout https://github.com/knuddelsgmbh/jtokkit for more details.</td><td>array of string</td><td></td><td>&quot;\n\n&quot;, &quot;\n&quot;, &quot; &quot;, &quot;&quot;</td></tr><tr><td><code>splitter_type</code></td><td>Splitter implementation to use. Currently supported: RecursiveCharacterTextSplitter.</td><td>string</td><td></td><td>RecursiveCharacterTextSplitter</td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="timer-source"></a>Timer source (<code>timer-source</code>)</h2><p data-full-width="true">Periodically emits records to trigger the execution of pipelines.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>fields</code></td><td>Fields of the generated records.</td><td><a href="#timer-source.fields">array of object</a></td><td></td><td></td></tr><tr><td><code>period-seconds</code></td><td>Period of the timer in seconds.</td><td>integer</td><td></td><td>60</td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="timer-source.fields"></a>Timer source (<code>timer-source</code>).fields</h3><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>expression</code></td><td>Expression to compute the value of the field. This is a standard EL expression.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>name</code></td><td>Name of the field like value.xx, key.xxx, properties.xxx</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="trigger-event"></a>Trigger event (<code>trigger-event</code>)</h2><p data-full-width="true">Emits a record on a side destination when a record is received.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>continue-processing</code></td><td>Whether to continue processing the record downstream after emitting the event.<br>If the when condition is false, the record is passed downstream anyway.<br>This flag allows you to stop processing system events and trigger a different pipeline.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>destination</code></td><td>Destination of the message.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>fields</code></td><td>Fields of the generated records.</td><td><a href="#trigger-event.fields">array of object</a></td><td></td><td></td></tr><tr><td><code>when</code></td><td>Condition to trigger the event. This is a standard EL expression.</td><td>string</td><td></td><td>true</td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="trigger-event.fields"></a>Trigger event (<code>trigger-event</code>).fields</h3><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>expression</code></td><td>Expression to compute the value of the field. This is a standard EL expression.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>name</code></td><td>Name of the field like value.xx, key.xxx, properties.xxx</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="unwrap-key-value"></a>Unwrap key-value format (<code>unwrap-key-value</code>)</h2><p data-full-width="true">If the record value is in KeyValue format, extracts the KeyValue&#x27;s key or value and make it the record value.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>composable</code></td><td>Whether this step can be composed with other steps.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>unwrapKey</code></td><td>Whether to unwrap the key instead of the value.</td><td>boolean</td><td></td><td>false</td></tr><tr><td><code>when</code></td><td>Execute the step only when the condition is met.<br>You can use the expression language to reference the message.<br>Example: when: &quot;value.first == &#x27;f1&#x27; &amp;&amp; value.last.toUpperCase() == &#x27;L1&#x27;&quot;</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="vector-db-sink_astra"></a>Astra (<code>vector-db-sink</code>)</h2><p data-full-width="true">Writes data to DataStax Astra service.<br>All the options from DataStax Kafka Sink are supported: https://docs.datastax.com/en/kafka/doc/kafka/kafkaConfigTasksTOC.html</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>datasource</code></td><td>Resource id. The target resource must be type: &#x27;datasource&#x27; or &#x27;vector-database&#x27; and service: &#x27;astra&#x27;.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>keyspace</code></td><td>The keyspace of the table to write to.</td><td>string</td><td></td><td></td></tr><tr><td><code>mapping</code></td><td>Comma separated list of mapping between the table column and the record field. e.g. my_colum_id=key, my_column_name=value.name.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>table-name</code></td><td>The name of the table to write to. The table must already exist.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="vector-db-sink_cassandra"></a>Cassandra (<code>vector-db-sink</code>)</h2><p data-full-width="true">Writes data to Apache Cassandra.<br>All the options from DataStax Kafka Sink are supported: https://docs.datastax.com/en/kafka/doc/kafka/kafkaConfigTasksTOC.html</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>datasource</code></td><td>Resource id. The target resource must be type: &#x27;datasource&#x27; or &#x27;vector-database&#x27; and service: &#x27;cassandra&#x27;.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>keyspace</code></td><td>The keyspace of the table to write to.</td><td>string</td><td></td><td></td></tr><tr><td><code>mapping</code></td><td>Comma separated list of mapping between the table column and the record field. e.g. my_colum_id=key, my_column_name=value.name.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>table-name</code></td><td>The name of the table to write to. The table must already exist.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="vector-db-sink_jdbc"></a>JDBC (<code>vector-db-sink</code>)</h2><p data-full-width="true">Writes data to any JDBC compatible database.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>datasource</code></td><td>Resource id. The target resource must be type: &#x27;datasource&#x27; or &#x27;vector-database&#x27; and service: &#x27;jdbc&#x27;.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>fields</code></td><td>Fields of the table to write to.</td><td><a href="#vector-db-sink_jdbc.fields">array of object</a></td><td>✓</td><td></td></tr><tr><td><code>table-name</code></td><td>The name of the table to write to. The table must already exist.</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="vector-db-sink_jdbc.fields"></a>JDBC (<code>vector-db-sink</code>).fields</h3><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>expression</code></td><td>JSTL Expression for computing the field value.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>name</code></td><td>Field name</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>primary-key</code></td><td>Is this field part of the primary key?</td><td>boolean</td><td></td><td>false</td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="vector-db-sink_milvus"></a>Milvus (<code>vector-db-sink</code>)</h2><p data-full-width="true">Writes data to Milvus/Zillis service.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>collection-name</code></td><td>Collection name</td><td>string</td><td></td><td></td></tr><tr><td><code>database-name</code></td><td>Collection name</td><td>string</td><td></td><td></td></tr><tr><td><code>datasource</code></td><td>Resource id. The target resource must be type: &#x27;datasource&#x27; or &#x27;vector-database&#x27; and service: &#x27;milvus&#x27;.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>fields</code></td><td>Fields definition.</td><td><a href="#vector-db-sink_milvus.fields">array of object</a></td><td>✓</td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="vector-db-sink_milvus.fields"></a>Milvus (<code>vector-db-sink</code>).fields</h3><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>expression</code></td><td>JSTL Expression for computing the field value.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>name</code></td><td>Field name</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="vector-db-sink_opensearch"></a>OpenSearch (<code>vector-db-sink</code>)</h2><p data-full-width="true">Writes data to OpenSearch or AWS OpenSearch serverless.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>batch-size</code></td><td>Batch size for bulk operations. Hitting the batch size will trigger a flush.</td><td>integer</td><td></td><td>10</td></tr><tr><td><code>bulk-parameters</code></td><td>OpenSearch bulk URL parameters.</td><td>object</td><td></td><td></td></tr><tr><td><code>datasource</code></td><td>Resource id. The target resource must be type: &#x27;datasource&#x27; or &#x27;vector-database&#x27; and service: &#x27;opensearch&#x27;.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>fields</code></td><td>Index fields definition.</td><td><a href="#vector-db-sink_opensearch.fields">array of object</a></td><td>✓</td><td></td></tr><tr><td><code>flush-interval</code></td><td>Flush interval in milliseconds</td><td>integer</td><td></td><td>1000</td></tr><tr><td><code>id</code></td><td>JSTL Expression to compute the index _id field. Leave it empty to let OpenSearch auto-generate the _id field.</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="vector-db-sink_opensearch.bulk-parameters"></a>OpenSearch (<code>vector-db-sink</code>).bulk-parameters</h3><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>pipeline</code></td><td>The pipeline ID for preprocessing documents.<br>Refer to the OpenSearch documentation for more details.</td><td>string</td><td></td><td></td></tr><tr><td><code>routing</code></td><td>Routes the request to the specified shard.<br>Refer to the OpenSearch documentation for more details.</td><td>string</td><td></td><td></td></tr><tr><td><code>require_alias</code></td><td>Set to true to require that all actions target an index alias rather than an index.<br>Refer to the OpenSearch documentation for more details.</td><td>boolean</td><td></td><td></td></tr><tr><td><code>refresh</code></td><td>Whether to refresh the affected shards after performing the indexing operations. Default is false. true makes the changes show up in search results immediately, but hurts cluster performance. wait_for waits for a refresh. Requests take longer to return, but cluster performance doesn’t suffer.<br>Note that AWS OpenSearch supports only false.<br>Refer to the OpenSearch documentation for more details.</td><td>string</td><td></td><td></td></tr><tr><td><code>wait_for_active_shards</code></td><td>Specifies the number of active shards that must be available before OpenSearch processes the bulk request. Default is 1 (only the primary shard). Set to all or a positive integer. Values greater than 1 require replicas. For example, if you specify a value of 3, the index must have two replicas distributed across two additional nodes for the request to succeed.<br>Refer to the OpenSearch documentation for more details.</td><td>string</td><td></td><td></td></tr><tr><td><code>timeout</code></td><td>How long to wait for the request to return.<br>Refer to the OpenSearch documentation for more details.</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="vector-db-sink_opensearch.fields"></a>OpenSearch (<code>vector-db-sink</code>).fields</h3><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>expression</code></td><td>JSTL Expression for computing the field value.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>name</code></td><td>Field name</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="vector-db-sink_pinecone"></a>Pinecone (<code>vector-db-sink</code>)</h2><p data-full-width="true">Writes data to Pinecone service.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>datasource</code></td><td>Resource id. The target resource must be type: &#x27;datasource&#x27; or &#x27;vector-database&#x27; and service: &#x27;pinecone&#x27;.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>vector.id</code></td><td>JSTL Expression to compute the id.</td><td>string</td><td></td><td></td></tr><tr><td><code>vector.metadata</code></td><td>Metadata to append. The key is the metadata name and the value the JSTL Expression to compute the actual value.</td><td>object</td><td></td><td></td></tr><tr><td><code>vector.namespace</code></td><td>JSTL Expression to compute the namespace.</td><td>string</td><td></td><td></td></tr><tr><td><code>vector.vector</code></td><td>JSTL Expression to compute the vector.</td><td>string</td><td></td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="vector-db-sink_solr"></a>Apache Solr (<code>vector-db-sink</code>)</h2><p data-full-width="true">Writes data to Apache Solr service.<br>    The collection-name is configured at datasource level.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>commit-within</code></td><td>Commit within option</td><td>integer</td><td></td><td>1000</td></tr><tr><td><code>datasource</code></td><td>Resource id. The target resource must be type: &#x27;datasource&#x27; or &#x27;vector-database&#x27; and service: &#x27;solr&#x27;.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>fields</code></td><td>Fields definition.</td><td><a href="#vector-db-sink_solr.fields">array of object</a></td><td>✓</td><td></td></tr></tbody></table>

<br><h3 data-full-width="true"><a name="vector-db-sink_solr.fields"></a>Apache Solr (<code>vector-db-sink</code>).fields</h3><table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>expression</code></td><td>JSTL Expression for computing the field value.</td><td>string</td><td>✓</td><td></td></tr><tr><td><code>name</code></td><td>Field name</td><td>string</td><td>✓</td><td></td></tr></tbody></table>

<br><h2 data-full-width="true"><a name="webcrawler-source"></a>Web crawler source (<code>webcrawler-source</code>)</h2><p data-full-width="true">Crawl a website and extract the content of the pages.</p>

<table data-full-width="true"><thead><tr><th></th><th>Description</th><th>Type</th><th>Required</th><th>Default Value</th></tr></thead><tbody><tr><td><code>access-key</code></td><td>Configuration for handling the agent status.<br>Access key for the S3 server.</td><td>string</td><td></td><td>minioadmin</td></tr><tr><td><code>allowed-domains</code></td><td>Domains that the crawler is allowed to access.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>bucketName</code></td><td>Configuration for handling the agent status.<br>The name of the bucket.</td><td>string</td><td></td><td>langstream-source</td></tr><tr><td><code>endpoint</code></td><td>Configuration for handling the agent status.<br>The S3 endpoint.</td><td>string</td><td></td><td>http://minio-endpoint.-not-set:9090</td></tr><tr><td><code>forbidden-paths</code></td><td>Paths that the crawler is not allowed to access.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>handle-cookies</code></td><td>Whether to handle cookies.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>handle-robots-file</code></td><td>Whether to scan the HTML documents to find links to other pages.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>http-timeout</code></td><td>Timeout for HTTP requests. (in milliseconds)</td><td>integer</td><td></td><td>10000</td></tr><tr><td><code>max-depth</code></td><td>Maximum depth of the crawl.</td><td>integer</td><td></td><td>50</td></tr><tr><td><code>max-error-count</code></td><td>Maximum number of errors allowed before stopping.</td><td>integer</td><td></td><td>5</td></tr><tr><td><code>max-unflushed-pages</code></td><td>Maximum number of unflushed pages before the agent persists the crawl data.</td><td>integer</td><td></td><td>100</td></tr><tr><td><code>max-urls</code></td><td>Maximum number of URLs that can be crawled.</td><td>integer</td><td></td><td>1000</td></tr><tr><td><code>min-time-between-requests</code></td><td>Minimum time between two requests to the same domain. (in milliseconds)</td><td>integer</td><td></td><td>500</td></tr><tr><td><code>region</code></td><td>Configuration for handling the agent status.<br>Region for the S3 server.</td><td>string</td><td></td><td></td></tr><tr><td><code>reindex-interval-seconds</code></td><td>Time interval between reindexing of the pages.</td><td>integer</td><td></td><td>86400</td></tr><tr><td><code>scan-html-documents</code></td><td>Whether to scan HTML documents for links to other sites.</td><td>boolean</td><td></td><td>true</td></tr><tr><td><code>secret-key</code></td><td>Configuration for handling the agent status.<br>Secret key for the S3 server.</td><td>string</td><td></td><td>minioadmin</td></tr><tr><td><code>seed-urls</code></td><td>The starting URLs for the crawl.</td><td>array of string</td><td></td><td></td></tr><tr><td><code>user-agent</code></td><td>User agent to use for the requests.</td><td>string</td><td></td><td>Mozilla/5.0 (compatible; LangStream.ai/0.1; +https://langstream.ai)</td></tr></tbody></table>



